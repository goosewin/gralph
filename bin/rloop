#!/bin/bash
# rloop - Autonomous AI coding loops
# Version: 0.1.0

set -e

VERSION="0.1.0"

# Determine script and library directories
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LIB_DIR="${SCRIPT_DIR}/../lib"

# Alternative lib location when installed
if [[ ! -d "$LIB_DIR" ]] && [[ -d "${HOME}/.config/rloop/lib" ]]; then
    LIB_DIR="${HOME}/.config/rloop/lib"
fi

# Default configuration values
DEFAULT_MAX_ITERATIONS=30
DEFAULT_TASK_FILE="PRD.md"
DEFAULT_COMPLETION_MARKER="COMPLETE"
DEFAULT_MODEL=""

# ANSI color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Print usage information
usage() {
    cat << 'EOF'
rloop - Autonomous AI coding loops

USAGE:
  rloop <command> [options]

COMMANDS:
  start <dir>         Start a new ralph loop
  stop <name>         Stop a running loop
  stop --all          Stop all loops
  status              Show status of all loops
  logs <name>         View logs for a loop
  resume [name]       Resume crashed/stopped loops
  config              Manage configuration
  server              Start status API server
  version             Show version
  help                Show this help message

START OPTIONS:
  --name, -n          Session name (default: directory name)
  --max-iterations    Max iterations before giving up (default: 30)
  --task-file, -f     Task file path (default: PRD.md)
  --completion-marker Completion promise text (default: COMPLETE)
  --model, -m         Claude model override
  --webhook           Notification webhook URL
  --no-tmux           Run in foreground (blocks)

EXAMPLES:
  rloop start .
  rloop start ~/project --name myapp --max-iterations 50
  rloop status
  rloop logs myapp --follow
  rloop stop myapp
EOF
}

# Print error message and exit
die() {
    echo -e "${RED}Error:${NC} $1" >&2
    exit 1
}

# Print warning message
warn() {
    echo -e "${YELLOW}Warning:${NC} $1" >&2
}

# Print info message
info() {
    echo -e "${BLUE}Info:${NC} $1"
}

# Print success message
success() {
    echo -e "${GREEN}Success:${NC} $1"
}

# Parse command line arguments
# Sets global variables based on parsed arguments
parse_args() {
    # Global argument storage
    COMMAND=""
    POSITIONAL_ARGS=()

    # Start command options
    OPT_NAME=""
    OPT_MAX_ITERATIONS="$DEFAULT_MAX_ITERATIONS"
    OPT_TASK_FILE="$DEFAULT_TASK_FILE"
    OPT_COMPLETION_MARKER="$DEFAULT_COMPLETION_MARKER"
    OPT_MODEL="$DEFAULT_MODEL"
    OPT_WEBHOOK=""
    OPT_NO_TMUX=false

    # Stop command options
    OPT_ALL=false

    # Logs command options
    OPT_FOLLOW=false

    # Server command options
    OPT_PORT=""
    OPT_TOKEN=""

    # No arguments provided
    if [[ $# -eq 0 ]]; then
        usage
        exit 0
    fi

    # First argument is the command
    COMMAND="$1"
    shift

    # Parse remaining arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            # Help flags
            -h|--help)
                usage
                exit 0
                ;;

            # Name option (start command)
            -n|--name)
                if [[ -z "$2" ]] || [[ "$2" == -* ]]; then
                    die "Option --name requires a value"
                fi
                OPT_NAME="$2"
                shift 2
                ;;
            --name=*)
                OPT_NAME="${1#*=}"
                shift
                ;;

            # Max iterations option (start command)
            --max-iterations)
                if [[ -z "$2" ]] || [[ "$2" == -* ]]; then
                    die "Option --max-iterations requires a value"
                fi
                if ! [[ "$2" =~ ^[0-9]+$ ]]; then
                    die "Option --max-iterations must be a positive integer"
                fi
                OPT_MAX_ITERATIONS="$2"
                shift 2
                ;;
            --max-iterations=*)
                local val="${1#*=}"
                if ! [[ "$val" =~ ^[0-9]+$ ]]; then
                    die "Option --max-iterations must be a positive integer"
                fi
                OPT_MAX_ITERATIONS="$val"
                shift
                ;;

            # Task file option (start command)
            -f|--task-file)
                if [[ -z "$2" ]] || [[ "$2" == -* ]]; then
                    die "Option --task-file requires a value"
                fi
                OPT_TASK_FILE="$2"
                shift 2
                ;;
            --task-file=*)
                OPT_TASK_FILE="${1#*=}"
                shift
                ;;

            # Completion marker option (start command)
            --completion-marker)
                if [[ -z "$2" ]] || [[ "$2" == -* ]]; then
                    die "Option --completion-marker requires a value"
                fi
                OPT_COMPLETION_MARKER="$2"
                shift 2
                ;;
            --completion-marker=*)
                OPT_COMPLETION_MARKER="${1#*=}"
                shift
                ;;

            # Model option (start command)
            -m|--model)
                if [[ -z "$2" ]] || [[ "$2" == -* ]]; then
                    die "Option --model requires a value"
                fi
                OPT_MODEL="$2"
                shift 2
                ;;
            --model=*)
                OPT_MODEL="${1#*=}"
                shift
                ;;

            # Webhook option (start command)
            --webhook)
                if [[ -z "$2" ]] || [[ "$2" == -* ]]; then
                    die "Option --webhook requires a value"
                fi
                OPT_WEBHOOK="$2"
                shift 2
                ;;
            --webhook=*)
                OPT_WEBHOOK="${1#*=}"
                shift
                ;;

            # No tmux flag (start command)
            --no-tmux)
                OPT_NO_TMUX=true
                shift
                ;;

            # All flag (stop command)
            --all|-a)
                OPT_ALL=true
                shift
                ;;

            # Follow flag (logs command)
            --follow)
                OPT_FOLLOW=true
                shift
                ;;

            # Port option (server command)
            --port|-p)
                if [[ -z "$2" ]] || [[ "$2" == -* ]]; then
                    die "Option --port requires a value"
                fi
                if ! [[ "$2" =~ ^[0-9]+$ ]]; then
                    die "Option --port must be a positive integer"
                fi
                OPT_PORT="$2"
                shift 2
                ;;
            --port=*)
                local val="${1#*=}"
                if ! [[ "$val" =~ ^[0-9]+$ ]]; then
                    die "Option --port must be a positive integer"
                fi
                OPT_PORT="$val"
                shift
                ;;

            # Token option (server command)
            --token|-t)
                if [[ -z "$2" ]] || [[ "$2" == -* ]]; then
                    die "Option --token requires a value"
                fi
                OPT_TOKEN="$2"
                shift 2
                ;;
            --token=*)
                OPT_TOKEN="${1#*=}"
                shift
                ;;

            # Unknown option
            -*)
                die "Unknown option: $1"
                ;;

            # Positional argument
            *)
                POSITIONAL_ARGS+=("$1")
                shift
                ;;
        esac
    done
}

# Source library files
source_libs() {
    if [[ -f "$LIB_DIR/state.sh" ]]; then
        source "$LIB_DIR/state.sh"
    else
        die "Library not found: $LIB_DIR/state.sh"
    fi
    if [[ -f "$LIB_DIR/core.sh" ]]; then
        source "$LIB_DIR/core.sh"
    else
        die "Library not found: $LIB_DIR/core.sh"
    fi
}

# cmd_start() - Start a new ralph loop
# Validates inputs, creates tmux session, and saves state
cmd_start() {
    # Get directory from positional args
    local target_dir="${POSITIONAL_ARGS[0]}"

    if [[ -z "$target_dir" ]]; then
        die "Directory is required. Usage: rloop start <directory>"
    fi

    # Validate directory exists
    if [[ ! -d "$target_dir" ]]; then
        die "Directory does not exist: $target_dir"
    fi

    # Resolve to absolute path
    target_dir=$(cd "$target_dir" && pwd)

    # Validate task file exists
    local task_file_path="$target_dir/$OPT_TASK_FILE"
    if [[ ! -f "$task_file_path" ]]; then
        die "Task file does not exist: $task_file_path"
    fi

    # Determine session name (default to directory basename)
    local session_name="${OPT_NAME:-$(basename "$target_dir")}"

    # Sanitize session name for tmux (replace invalid chars with -)
    session_name=$(echo "$session_name" | sed 's/[^a-zA-Z0-9_-]/-/g')

    # Source library files
    source_libs

    # Initialize state
    if ! init_state; then
        die "Failed to initialize state"
    fi

    # Check for existing session with same name
    if get_session "$session_name" > /dev/null 2>&1; then
        local existing_status
        existing_status=$(get_session "$session_name" | jq -r '.status // "unknown"')
        if [[ "$existing_status" == "running" ]]; then
            # Check if the PID is actually alive
            local existing_pid
            existing_pid=$(get_session "$session_name" | jq -r '.pid // ""')
            if [[ -n "$existing_pid" ]] && kill -0 "$existing_pid" 2>/dev/null; then
                die "Session '$session_name' is already running (PID: $existing_pid). Use 'rloop stop $session_name' first."
            else
                warn "Session '$session_name' exists but appears stale. Restarting..."
            fi
        fi
    fi

    # Create .rloop directory in project
    local rloop_dir="$target_dir/.rloop"
    mkdir -p "$rloop_dir"

    local log_file="$rloop_dir/ralph.log"
    local tmux_session="rloop-$session_name"

    # Get initial task count
    local initial_count
    initial_count=$(grep -cE '^\s*- \[ \]' "$task_file_path" 2>/dev/null || echo "0")

    info "Starting ralph loop..."
    info "  Directory: $target_dir"
    info "  Session: $session_name"
    info "  Task file: $OPT_TASK_FILE"
    info "  Max iterations: $OPT_MAX_ITERATIONS"
    info "  Completion marker: $OPT_COMPLETION_MARKER"
    info "  Remaining tasks: $initial_count"
    if [[ -n "$OPT_MODEL" ]]; then
        info "  Model: $OPT_MODEL"
    fi

    if [[ "$OPT_NO_TMUX" == "true" ]]; then
        # Run in foreground (blocking)
        info "Running in foreground mode..."

        # Save state with PID of this process
        set_session "$session_name" \
            "dir=$target_dir" \
            "task_file=$OPT_TASK_FILE" \
            "pid=$$" \
            "tmux_session=" \
            "started_at=$(date -Iseconds)" \
            "iteration=1" \
            "max_iterations=$OPT_MAX_ITERATIONS" \
            "status=running" \
            "last_task_count=$initial_count" \
            "completion_marker=$OPT_COMPLETION_MARKER" \
            "log_file=$log_file" \
            "model=$OPT_MODEL" \
            "webhook=$OPT_WEBHOOK"

        # Run the loop directly
        run_loop \
            "$target_dir" \
            "$OPT_TASK_FILE" \
            "$OPT_MAX_ITERATIONS" \
            "$OPT_COMPLETION_MARKER" \
            "$OPT_MODEL" \
            "$session_name"

        local exit_code=$?

        # Update state based on result
        if [[ $exit_code -eq 0 ]]; then
            set_session "$session_name" "status=complete"
        else
            set_session "$session_name" "status=failed"
        fi

        return $exit_code
    else
        # Run in tmux session (background)

        # Check if tmux is available
        if ! command -v tmux &> /dev/null; then
            die "tmux is required for background mode. Install tmux or use --no-tmux flag."
        fi

        # Kill existing tmux session if it exists
        tmux kill-session -t "$tmux_session" 2>/dev/null || true

        # Build the command to run in tmux
        # We need to source the libs and call run_loop
        local rloop_cmd="source '$LIB_DIR/state.sh' && source '$LIB_DIR/core.sh' && "
        rloop_cmd+="RLOOP_STATE_CALLBACK=_update_session_state "
        rloop_cmd+="_update_session_state() { "
        rloop_cmd+="  set_session \"\$1\" iteration=\"\$2\" status=\"\$3\" last_task_count=\"\$4\"; "
        rloop_cmd+="}; "
        rloop_cmd+="run_loop "
        rloop_cmd+="'$target_dir' "
        rloop_cmd+="'$OPT_TASK_FILE' "
        rloop_cmd+="'$OPT_MAX_ITERATIONS' "
        rloop_cmd+="'$OPT_COMPLETION_MARKER' "
        rloop_cmd+="'$OPT_MODEL' "
        rloop_cmd+="'$session_name'; "
        rloop_cmd+="exit_code=\$?; "
        rloop_cmd+="if [ \$exit_code -eq 0 ]; then "
        rloop_cmd+="  set_session '$session_name' status=complete; "
        rloop_cmd+="else "
        rloop_cmd+="  set_session '$session_name' status=failed; "
        rloop_cmd+="fi"

        # Start tmux session
        tmux new-session -d -s "$tmux_session" "bash -c '$rloop_cmd'"

        # Get the PID of the tmux session's shell
        local tmux_pid
        tmux_pid=$(tmux list-panes -t "$tmux_session" -F '#{pane_pid}' 2>/dev/null | head -1)

        # Save state
        set_session "$session_name" \
            "dir=$target_dir" \
            "task_file=$OPT_TASK_FILE" \
            "pid=$tmux_pid" \
            "tmux_session=$tmux_session" \
            "started_at=$(date -Iseconds)" \
            "iteration=1" \
            "max_iterations=$OPT_MAX_ITERATIONS" \
            "status=running" \
            "last_task_count=$initial_count" \
            "completion_marker=$OPT_COMPLETION_MARKER" \
            "log_file=$log_file" \
            "model=$OPT_MODEL" \
            "webhook=$OPT_WEBHOOK"

        success "Ralph loop started in tmux session: $tmux_session"
        echo ""
        echo "Useful commands:"
        echo "  rloop status            - View all running loops"
        echo "  rloop logs $session_name      - View logs"
        echo "  rloop logs $session_name --follow - Follow logs"
        echo "  rloop stop $session_name      - Stop this loop"
        echo "  tmux attach -t $tmux_session  - Attach to tmux session"
    fi
}

# cmd_stop() - Stop a running ralph loop
# Finds session by name, kills tmux session, updates state
cmd_stop() {
    # Source library files
    source_libs

    # Ensure state is initialized
    if ! init_state; then
        die "Failed to initialize state"
    fi

    # Handle --all flag
    if [[ "$OPT_ALL" == "true" ]]; then
        local sessions
        sessions=$(list_sessions)

        if [[ -z "$sessions" ]] || [[ "$sessions" == "[]" ]]; then
            info "No sessions found"
            return 0
        fi

        local stopped_count=0
        local session_names
        session_names=$(echo "$sessions" | jq -r '.[].name // empty' 2>/dev/null)

        for session_name in $session_names; do
            local session
            session=$(get_session "$session_name")
            if [[ -z "$session" ]]; then
                continue
            fi

            local status
            status=$(echo "$session" | jq -r '.status // "unknown"')

            # Skip already stopped/completed sessions
            if [[ "$status" != "running" ]]; then
                continue
            fi

            local tmux_session
            tmux_session=$(echo "$session" | jq -r '.tmux_session // empty')

            # Kill tmux session if it exists
            if [[ -n "$tmux_session" ]]; then
                if tmux kill-session -t "$tmux_session" 2>/dev/null; then
                    info "Killed tmux session: $tmux_session"
                fi
            else
                # Foreground mode - kill by PID
                local pid
                pid=$(echo "$session" | jq -r '.pid // empty')
                if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
                    kill "$pid" 2>/dev/null || true
                    info "Killed process: $pid"
                fi
            fi

            # Update state to stopped
            set_session "$session_name" status="stopped"
            stopped_count=$((stopped_count + 1))
            info "Stopped session: $session_name"
        done

        if [[ $stopped_count -eq 0 ]]; then
            info "No running sessions to stop"
        else
            success "Stopped $stopped_count session(s)"
        fi
        return 0
    fi

    # Single session stop mode
    local session_name="${POSITIONAL_ARGS[0]}"

    if [[ -z "$session_name" ]]; then
        die "Session name is required. Usage: rloop stop <name> or rloop stop --all"
    fi

    # Find session by name
    local session
    if ! session=$(get_session "$session_name"); then
        die "Session not found: $session_name"
    fi

    local status
    status=$(echo "$session" | jq -r '.status // "unknown"')

    # Warn if not running
    if [[ "$status" != "running" ]]; then
        warn "Session '$session_name' is not running (status: $status)"
    fi

    local tmux_session
    tmux_session=$(echo "$session" | jq -r '.tmux_session // empty')

    # Kill tmux session if it exists
    if [[ -n "$tmux_session" ]]; then
        if tmux kill-session -t "$tmux_session" 2>/dev/null; then
            info "Killed tmux session: $tmux_session"
        else
            warn "Tmux session '$tmux_session' not found (may have already exited)"
        fi
    else
        # Foreground mode - kill by PID
        local pid
        pid=$(echo "$session" | jq -r '.pid // empty')
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            kill "$pid" 2>/dev/null || true
            info "Killed process: $pid"
        else
            warn "Process not found (may have already exited)"
        fi
    fi

    # Update state to stopped
    set_session "$session_name" status="stopped"

    success "Stopped session: $session_name"
}

cmd_status() {
    die "cmd_status not yet implemented"
}

cmd_logs() {
    die "cmd_logs not yet implemented"
}

cmd_resume() {
    die "cmd_resume not yet implemented"
}

cmd_config() {
    die "cmd_config not yet implemented"
}

cmd_server() {
    die "cmd_server not yet implemented"
}

cmd_version() {
    echo "rloop v$VERSION"
}

# Main entry point
main() {
    parse_args "$@"

    case "$COMMAND" in
        start)
            cmd_start
            ;;
        stop)
            cmd_stop
            ;;
        status)
            cmd_status
            ;;
        logs)
            cmd_logs
            ;;
        resume)
            cmd_resume
            ;;
        config)
            cmd_config
            ;;
        server)
            cmd_server
            ;;
        version|--version|-v)
            cmd_version
            ;;
        help|--help|-h)
            usage
            ;;
        "")
            usage
            ;;
        *)
            die "Unknown command: $COMMAND. Run 'rloop help' for usage."
            ;;
    esac
}

main "$@"
