#!/usr/bin/env bash
# gralph - Autonomous AI coding loops
# Version: 1.1.0

set -e

VERSION="1.1.0"

# Ensure bash 4+ for associative arrays
if [[ -n "${BASH_VERSINFO[0]:-}" ]] && (( BASH_VERSINFO[0] < 4 )); then
    echo "Error: gralph requires bash 4+ (found ${BASH_VERSINFO[0]})." >&2
    echo "Install a newer bash and run with it, for example:" >&2
    echo "  brew install bash" >&2
    echo "  $(brew --prefix 2>/dev/null)/bin/bash $(command -v gralph) <args>" >&2
    exit 1
fi

# Determine script and library directories
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LIB_DIR="${SCRIPT_DIR}/../lib"

# Alternative lib location when installed
# Prefer fallback if the expected library files are missing
if [[ ! -f "$LIB_DIR/state.sh" ]] && [[ -d "${HOME}/.config/gralph/lib" ]]; then
    LIB_DIR="${HOME}/.config/gralph/lib"
fi

# Default configuration values
DEFAULT_MAX_ITERATIONS=30
DEFAULT_TASK_FILE="PRD.md"
DEFAULT_COMPLETION_MARKER="COMPLETE"
DEFAULT_MODEL=""
DEFAULT_VARIANT=""

# ANSI color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Print usage information
usage() {
    cat << 'EOF'
gralph - Autonomous AI coding loops

USAGE:
  gralph <command> [options]

COMMANDS:
  start <dir>         Start a new gralph loop
  stop <name>         Stop a running loop
  stop --all          Stop all loops
  status              Show status of all loops
  logs <name>         View logs for a loop
  resume [name]       Resume crashed/stopped loops
  backends            List available AI backends
  config              Manage configuration
  server              Start status API server
  version             Show version
  help                Show this help message

START OPTIONS:
  --name, -n          Session name (default: directory name)
  --max-iterations    Max iterations before giving up (default: 30)
  --task-file, -f     Task file path (default: PRD.md)
  --completion-marker Completion promise text (default: COMPLETE)
  --backend, -b       AI backend: claude or opencode (default: claude)
  --model, -m         Model override (format depends on backend)
  --variant           Model variant override (backend-specific)
  --prompt-template   Path to custom prompt template file
  --webhook           Notification webhook URL
  --no-tmux           Run in foreground (blocks)

EXAMPLES:
  gralph start .
  gralph start ~/project --name myapp --max-iterations 50
  gralph status
  gralph logs myapp --follow
  gralph stop myapp
EOF
}

# Print error message and exit
die() {
    echo -e "${RED}Error:${NC} $1" >&2
    exit 1
}

# Print warning message
warn() {
    echo -e "${YELLOW}Warning:${NC} $1" >&2
}

# Print info message
info() {
    echo -e "${BLUE}Info:${NC} $1"
}

# Print success message
success() {
    echo -e "${GREEN}Success:${NC} $1"
}

# Parse command line arguments
# Sets global variables based on parsed arguments
parse_args() {
    # Global argument storage
    COMMAND=""
    POSITIONAL_ARGS=()

    # Start command options
    OPT_NAME=""
    OPT_MAX_ITERATIONS="$DEFAULT_MAX_ITERATIONS"
    OPT_TASK_FILE="$DEFAULT_TASK_FILE"
    OPT_COMPLETION_MARKER="$DEFAULT_COMPLETION_MARKER"
    OPT_BACKEND=""
    OPT_MODEL="$DEFAULT_MODEL"
    OPT_VARIANT="${GRALPH_VARIANT:-$DEFAULT_VARIANT}"
    OPT_PROMPT_TEMPLATE_FILE=""
    OPT_WEBHOOK=""
    OPT_NO_TMUX=false

    OPT_NAME_SET=false
    OPT_MAX_ITERATIONS_SET=false
    OPT_TASK_FILE_SET=false
    OPT_COMPLETION_MARKER_SET=false
    OPT_BACKEND_SET=false
    OPT_MODEL_SET=false
    OPT_VARIANT_SET=false
    OPT_PROMPT_TEMPLATE_FILE_SET=false
    OPT_WEBHOOK_SET=false
    OPT_NO_TMUX_SET=false

    # Stop command options
    OPT_ALL=false

    # Logs command options
    OPT_FOLLOW=false

    # Server command options
    OPT_PORT=""
    OPT_TOKEN=""

    # No arguments provided
    if [[ $# -eq 0 ]]; then
        usage
        exit 0
    fi

    # First argument is the command
    COMMAND="$1"
    shift

    # Parse remaining arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            # Help flags
            -h|--help)
                usage
                exit 0
                ;;

            # Name option (start command)
            -n|--name)
                if [[ -z "$2" ]] || [[ "$2" == -* ]]; then
                    die "Option --name requires a value"
                fi
                OPT_NAME="$2"
                OPT_NAME_SET=true
                shift 2
                ;;
            --name=*)
                OPT_NAME="${1#*=}"
                OPT_NAME_SET=true
                shift
                ;;

            # Max iterations option (start command)
            --max-iterations)
                if [[ -z "$2" ]] || [[ "$2" == -* ]]; then
                    die "Option --max-iterations requires a value"
                fi
                if ! [[ "$2" =~ ^[0-9]+$ ]]; then
                    die "Option --max-iterations must be a positive integer"
                fi
                OPT_MAX_ITERATIONS="$2"
                OPT_MAX_ITERATIONS_SET=true
                shift 2
                ;;
            --max-iterations=*)
                local val="${1#*=}"
                if ! [[ "$val" =~ ^[0-9]+$ ]]; then
                    die "Option --max-iterations must be a positive integer"
                fi
                OPT_MAX_ITERATIONS="$val"
                OPT_MAX_ITERATIONS_SET=true
                shift
                ;;

            # Task file option (start command)
            -f|--task-file)
                if [[ -z "$2" ]] || [[ "$2" == -* ]]; then
                    die "Option --task-file requires a value"
                fi
                OPT_TASK_FILE="$2"
                OPT_TASK_FILE_SET=true
                shift 2
                ;;
            --task-file=*)
                OPT_TASK_FILE="${1#*=}"
                OPT_TASK_FILE_SET=true
                shift
                ;;

            # Completion marker option (start command)
            --completion-marker)
                if [[ -z "$2" ]] || [[ "$2" == -* ]]; then
                    die "Option --completion-marker requires a value"
                fi
                OPT_COMPLETION_MARKER="$2"
                OPT_COMPLETION_MARKER_SET=true
                shift 2
                ;;
            --completion-marker=*)
                OPT_COMPLETION_MARKER="${1#*=}"
                OPT_COMPLETION_MARKER_SET=true
                shift
                ;;

            # Backend option (start command)
            -b|--backend)
                if [[ -z "$2" ]] || [[ "$2" == -* ]]; then
                    die "Option --backend requires a value"
                fi
                if [[ "$2" != "claude" ]] && [[ "$2" != "opencode" ]]; then
                    die "Option --backend must be 'claude' or 'opencode'"
                fi
                OPT_BACKEND="$2"
                OPT_BACKEND_SET=true
                shift 2
                ;;
            --backend=*)
                local val="${1#*=}"
                if [[ "$val" != "claude" ]] && [[ "$val" != "opencode" ]]; then
                    die "Option --backend must be 'claude' or 'opencode'"
                fi
                OPT_BACKEND="$val"
                OPT_BACKEND_SET=true
                shift
                ;;

            # Model option (start command)
            -m|--model)
                if [[ -z "$2" ]] || [[ "$2" == -* ]]; then
                    die "Option --model requires a value"
                fi
                OPT_MODEL="$2"
                OPT_MODEL_SET=true
                shift 2
                ;;
            --model=*)
                OPT_MODEL="${1#*=}"
                OPT_MODEL_SET=true
                shift
                ;;

            # Variant option (start command)
            --variant)
                if [[ -z "$2" ]] || [[ "$2" == -* ]]; then
                    die "Option --variant requires a value"
                fi
                OPT_VARIANT="$2"
                OPT_VARIANT_SET=true
                shift 2
                ;;
            --variant=*)
                OPT_VARIANT="${1#*=}"
                OPT_VARIANT_SET=true
                shift
                ;;

            # Prompt template option (start command)
            --prompt-template)
                if [[ -z "$2" ]] || [[ "$2" == -* ]]; then
                    die "Option --prompt-template requires a file path"
                fi
                OPT_PROMPT_TEMPLATE_FILE="$2"
                OPT_PROMPT_TEMPLATE_FILE_SET=true
                shift 2
                ;;
            --prompt-template=*)
                OPT_PROMPT_TEMPLATE_FILE="${1#*=}"
                OPT_PROMPT_TEMPLATE_FILE_SET=true
                shift
                ;;

            # Webhook option (start command)
            --webhook)
                if [[ -z "$2" ]] || [[ "$2" == -* ]]; then
                    die "Option --webhook requires a value"
                fi
                OPT_WEBHOOK="$2"
                OPT_WEBHOOK_SET=true
                shift 2
                ;;
            --webhook=*)
                OPT_WEBHOOK="${1#*=}"
                OPT_WEBHOOK_SET=true
                shift
                ;;

            # No tmux flag (start command)
            --no-tmux)
                OPT_NO_TMUX=true
                OPT_NO_TMUX_SET=true
                shift
                ;;

            # All flag (stop command)
            --all|-a)
                OPT_ALL=true
                shift
                ;;

            # Follow flag (logs command)
            --follow)
                OPT_FOLLOW=true
                shift
                ;;

            # Port option (server command)
            --port|-p)
                if [[ -z "$2" ]] || [[ "$2" == -* ]]; then
                    die "Option --port requires a value"
                fi
                if ! [[ "$2" =~ ^[0-9]+$ ]]; then
                    die "Option --port must be a positive integer"
                fi
                OPT_PORT="$2"
                shift 2
                ;;
            --port=*)
                local val="${1#*=}"
                if ! [[ "$val" =~ ^[0-9]+$ ]]; then
                    die "Option --port must be a positive integer"
                fi
                OPT_PORT="$val"
                shift
                ;;

            # Token option (server command)
            --token|-t)
                if [[ -z "$2" ]] || [[ "$2" == -* ]]; then
                    die "Option --token requires a value"
                fi
                OPT_TOKEN="$2"
                shift 2
                ;;
            --token=*)
                OPT_TOKEN="${1#*=}"
                shift
                ;;

            # Unknown option
            -*)
                die "Unknown option: $1"
                ;;

            # Positional argument
            *)
                POSITIONAL_ARGS+=("$1")
                shift
                ;;
        esac
    done
}

# Source library files
source_libs() {
    if [[ -f "$LIB_DIR/state.sh" ]]; then
        source "$LIB_DIR/state.sh"
    else
        die "Library not found: $LIB_DIR/state.sh"
    fi
    if [[ -f "$LIB_DIR/backends/common.sh" ]]; then
        source "$LIB_DIR/backends/common.sh"
    else
        die "Library not found: $LIB_DIR/backends/common.sh"
    fi
    if [[ -f "$LIB_DIR/core.sh" ]]; then
        source "$LIB_DIR/core.sh"
    else
        die "Library not found: $LIB_DIR/core.sh"
    fi
}

# cmd_start() - Start a new gralph loop
# Validates inputs, creates tmux session, and saves state
cmd_start() {
    # Get directory from positional args
    local target_dir="${POSITIONAL_ARGS[0]}"

    if [[ -z "$target_dir" ]]; then
        die "Directory is required. Usage: gralph start <directory>"
    fi

    # Validate directory exists
    if [[ ! -d "$target_dir" ]]; then
        die "Directory does not exist: $target_dir"
    fi

    # Resolve to absolute path
    target_dir=$(cd "$target_dir" && pwd)

    # Load configuration defaults (if available) for this project
    if [[ -f "$LIB_DIR/config.sh" ]]; then
        source "$LIB_DIR/config.sh"
        load_config "$target_dir"

        if [[ "$OPT_MAX_ITERATIONS_SET" != "true" ]]; then
            OPT_MAX_ITERATIONS=$(get_config "defaults.max_iterations" "$OPT_MAX_ITERATIONS")
        fi
        if [[ "$OPT_TASK_FILE_SET" != "true" ]]; then
            OPT_TASK_FILE=$(get_config "defaults.task_file" "$OPT_TASK_FILE")
        fi
        if [[ "$OPT_COMPLETION_MARKER_SET" != "true" ]]; then
            OPT_COMPLETION_MARKER=$(get_config "defaults.completion_marker" "$OPT_COMPLETION_MARKER")
        fi
        if [[ "$OPT_BACKEND_SET" != "true" ]]; then
            OPT_BACKEND=$(get_config "defaults.backend" "$OPT_BACKEND")
        fi
        if [[ "$OPT_MODEL_SET" != "true" ]]; then
            OPT_MODEL=$(get_config "defaults.model" "$OPT_MODEL")
        fi
        if [[ -z "$OPT_MODEL" ]] && [[ "${OPT_BACKEND:-claude}" == "opencode" ]]; then
            OPT_MODEL=$(get_config "opencode.default_model" "$OPT_MODEL")
        fi
    fi

    # Validate configured values
    if ! [[ "$OPT_MAX_ITERATIONS" =~ ^[0-9]+$ ]]; then
        die "Configured max_iterations must be a positive integer"
    fi
    if [[ -n "$OPT_BACKEND" ]] && [[ "$OPT_BACKEND" != "claude" ]] && [[ "$OPT_BACKEND" != "opencode" ]]; then
        die "Configured backend must be 'claude' or 'opencode'"
    fi
    if [[ -z "$OPT_COMPLETION_MARKER" ]]; then
        die "Configured completion marker cannot be empty"
    fi

    # Validate task file exists
    local task_file_path="$target_dir/$OPT_TASK_FILE"
    if [[ ! -f "$task_file_path" ]]; then
        die "Task file does not exist: $task_file_path"
    fi

    # Determine session name (default to directory basename)
    local session_name="${OPT_NAME:-$(basename "$target_dir")}"

    # Sanitize session name for tmux (replace invalid chars with -)
    session_name=$(echo "$session_name" | sed 's/[^a-zA-Z0-9_-]/-/g')

    # Source library files
    source_libs

    # Initialize state
    if ! init_state; then
        die "Failed to initialize state"
    fi

    # Check for existing session with same name
    if get_session "$session_name" > /dev/null 2>&1; then
        local existing_status
        existing_status=$(get_session "$session_name" | jq -r '.status // "unknown"')
        if [[ "$existing_status" == "running" ]]; then
            # Check if the PID is actually alive
            local existing_pid
            existing_pid=$(get_session "$session_name" | jq -r '.pid // ""')
            if [[ -n "$existing_pid" ]] && kill -0 "$existing_pid" 2>/dev/null; then
                die "Session '$session_name' is already running (PID: $existing_pid). Use 'gralph stop $session_name' first."
            else
                warn "Session '$session_name' exists but appears stale. Restarting..."
            fi
        fi
    fi

    # Create .gralph directory in project
    local gralph_dir="$target_dir/.gralph"
    mkdir -p "$gralph_dir"

    local log_file="$gralph_dir/gralph.log"
    local tmux_session="gralph-$session_name"

    # Handle prompt template file (optional)
    if [[ -n "$OPT_PROMPT_TEMPLATE_FILE" ]]; then
        local prompt_template_file="$OPT_PROMPT_TEMPLATE_FILE"

        if [[ "$prompt_template_file" != /* ]]; then
            prompt_template_file="$(pwd)/$prompt_template_file"
        fi

        if [[ ! -f "$prompt_template_file" ]]; then
            die "Prompt template file does not exist: $prompt_template_file"
        fi

        if ! cp "$prompt_template_file" "$gralph_dir/prompt-template.txt"; then
            die "Failed to copy prompt template to $gralph_dir/prompt-template.txt"
        fi
    fi

    # Get initial task count
    local initial_count
    initial_count=$(grep -cE '^\s*- \[ \]' "$task_file_path" 2>/dev/null || echo "0")

    # Determine backend (CLI option > config > default)
    local backend="${OPT_BACKEND:-claude}"

    # Initialize and validate backend
    if ! init_backend "$backend"; then
        die "Failed to initialize backend: $backend"
    fi

    info "Starting gralph loop..."
    info "  Directory: $target_dir"
    info "  Session: $session_name"
    info "  Task file: $OPT_TASK_FILE"
    info "  Max iterations: $OPT_MAX_ITERATIONS"
    info "  Completion marker: $OPT_COMPLETION_MARKER"
    info "  Backend: $backend"
    info "  Remaining tasks: $initial_count"
    if [[ -n "$OPT_PROMPT_TEMPLATE_FILE" ]]; then
        info "  Prompt template: $gralph_dir/prompt-template.txt"
    fi
    if [[ -n "$OPT_MODEL" ]]; then
        info "  Model: $OPT_MODEL"
    fi
    if [[ -n "$OPT_VARIANT" ]]; then
        info "  Variant: $OPT_VARIANT"
    fi

    if [[ "$OPT_NO_TMUX" == "true" ]]; then
        # Run in foreground (blocking)
        info "Running in foreground mode..."

        # Save state with PID of this process
        set_session "$session_name" \
            "dir=$target_dir" \
            "task_file=$OPT_TASK_FILE" \
            "pid=$$" \
            "tmux_session=" \
            "started_at=$(date -Iseconds)" \
            "iteration=1" \
            "max_iterations=$OPT_MAX_ITERATIONS" \
            "status=running" \
            "last_task_count=$initial_count" \
            "completion_marker=$OPT_COMPLETION_MARKER" \
            "log_file=$log_file" \
            "backend=$backend" \
            "model=$OPT_MODEL" \
            "variant=$OPT_VARIANT" \
            "webhook=$OPT_WEBHOOK"

        GRALPH_STATE_CALLBACK="_update_session_state"
        _update_session_state() {
            set_session "$1" iteration="$2" status="$3" last_task_count="$4"
        }
        export GRALPH_STATE_CALLBACK

        # Set backend for the loop
        export GRALPH_BACKEND="$backend"
        if [[ -n "$OPT_VARIANT" ]]; then
            export GRALPH_VARIANT="$OPT_VARIANT"
        fi

        # Run the loop directly
        run_loop \
            "$target_dir" \
            "$OPT_TASK_FILE" \
            "$OPT_MAX_ITERATIONS" \
            "$OPT_COMPLETION_MARKER" \
            "$OPT_MODEL" \
            "$session_name"

        local exit_code=$?

        # Update state based on result
        if [[ $exit_code -eq 0 ]]; then
            set_session "$session_name" "status=complete"
        else
            set_session "$session_name" "status=failed"
        fi

        return $exit_code
    else
        # Run in tmux session (background)

        # Check if tmux is available
        if ! command -v tmux &> /dev/null; then
            die "tmux is required for background mode. Install tmux or use --no-tmux flag."
        fi

        # Kill existing tmux session if it exists
        tmux kill-session -t "$tmux_session" 2>/dev/null || true

        # Build the command to run in tmux
        # We need to source the libs and call run_loop
        local gralph_cmd="source '$LIB_DIR/state.sh' && source '$LIB_DIR/backends/common.sh' && source '$LIB_DIR/core.sh' && "
        gralph_cmd+="export GRALPH_BACKEND='$backend' && "
        if [[ -n "$OPT_VARIANT" ]]; then
            gralph_cmd+="export GRALPH_VARIANT='$OPT_VARIANT' && "
        fi
        gralph_cmd+="init_backend '$backend' && "
        gralph_cmd+="GRALPH_STATE_CALLBACK=_update_session_state "
        gralph_cmd+="_update_session_state() { "
        gralph_cmd+="  set_session \"\$1\" iteration=\"\$2\" status=\"\$3\" last_task_count=\"\$4\"; "
        gralph_cmd+="}; "
        gralph_cmd+="run_loop "
        gralph_cmd+="'$target_dir' "
        gralph_cmd+="'$OPT_TASK_FILE' "
        gralph_cmd+="'$OPT_MAX_ITERATIONS' "
        gralph_cmd+="'$OPT_COMPLETION_MARKER' "
        gralph_cmd+="'$OPT_MODEL' "
        gralph_cmd+="'$session_name'; "
        gralph_cmd+="exit_code=\$?; "
        gralph_cmd+="if [ \$exit_code -eq 0 ]; then "
        gralph_cmd+="  set_session '$session_name' status=complete; "
        gralph_cmd+="else "
        gralph_cmd+="  set_session '$session_name' status=failed; "
        gralph_cmd+="fi"

        # Start tmux session
        tmux new-session -d -s "$tmux_session" bash -lc "$gralph_cmd"

        # Get the PID of the tmux session's shell
        local tmux_pid
        tmux_pid=$(tmux list-panes -t "$tmux_session" -F '#{pane_pid}' 2>/dev/null | head -1)

        # Save state
        set_session "$session_name" \
            "dir=$target_dir" \
            "task_file=$OPT_TASK_FILE" \
            "pid=$tmux_pid" \
            "tmux_session=$tmux_session" \
            "started_at=$(date -Iseconds)" \
            "iteration=1" \
            "max_iterations=$OPT_MAX_ITERATIONS" \
            "status=running" \
            "last_task_count=$initial_count" \
            "completion_marker=$OPT_COMPLETION_MARKER" \
            "log_file=$log_file" \
            "backend=$backend" \
            "model=$OPT_MODEL" \
            "variant=$OPT_VARIANT" \
            "webhook=$OPT_WEBHOOK"

        success "Gralph loop started in tmux session: $tmux_session"
        echo ""
        echo "Useful commands:"
        echo "  gralph status            - View all running loops"
        echo "  gralph logs $session_name      - View logs"
        echo "  gralph logs $session_name --follow - Follow logs"
        echo "  gralph stop $session_name      - Stop this loop"
        echo "  tmux attach -t $tmux_session  - Attach to tmux session"
    fi
}

# cmd_stop() - Stop a running gralph loop
# Finds session by name, kills tmux session, updates state
cmd_stop() {
    # Source library files
    source_libs

    # Ensure state is initialized
    if ! init_state; then
        die "Failed to initialize state"
    fi

    # Handle --all flag
    if [[ "$OPT_ALL" == "true" ]]; then
        local sessions
        sessions=$(list_sessions)

        if [[ -z "$sessions" ]] || [[ "$sessions" == "[]" ]]; then
            info "No sessions found"
            return 0
        fi

        local stopped_count=0
        local session_names
        session_names=$(echo "$sessions" | jq -r '.[].name // empty' 2>/dev/null)

        for session_name in $session_names; do
            local session
            session=$(get_session "$session_name")
            if [[ -z "$session" ]]; then
                continue
            fi

            local status
            status=$(echo "$session" | jq -r '.status // "unknown"')

            # Skip already stopped/completed sessions
            if [[ "$status" != "running" ]]; then
                continue
            fi

            local tmux_session
            tmux_session=$(echo "$session" | jq -r '.tmux_session // empty')

            # Kill tmux session if it exists
            if [[ -n "$tmux_session" ]]; then
                if tmux kill-session -t "$tmux_session" 2>/dev/null; then
                    info "Killed tmux session: $tmux_session"
                fi
            else
                # Foreground mode - kill by PID
                local pid
                pid=$(echo "$session" | jq -r '.pid // empty')
                if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
                    kill "$pid" 2>/dev/null || true
                    info "Killed process: $pid"
                fi
            fi

            # Update state to stopped
            set_session "$session_name" status="stopped" pid="" tmux_session=""
            stopped_count=$((stopped_count + 1))
            info "Stopped session: $session_name"
        done

        if [[ $stopped_count -eq 0 ]]; then
            info "No running sessions to stop"
        else
            success "Stopped $stopped_count session(s)"
        fi
        return 0
    fi

    # Single session stop mode
    local session_name="${POSITIONAL_ARGS[0]}"

    if [[ -z "$session_name" ]]; then
        die "Session name is required. Usage: gralph stop <name> or gralph stop --all"
    fi

    # Find session by name
    local session
    if ! session=$(get_session "$session_name"); then
        die "Session not found: $session_name"
    fi

    local status
    status=$(echo "$session" | jq -r '.status // "unknown"')

    # Warn if not running
    if [[ "$status" != "running" ]]; then
        warn "Session '$session_name' is not running (status: $status)"
    fi

    local tmux_session
    tmux_session=$(echo "$session" | jq -r '.tmux_session // empty')

    # Kill tmux session if it exists
    if [[ -n "$tmux_session" ]]; then
        if tmux kill-session -t "$tmux_session" 2>/dev/null; then
            info "Killed tmux session: $tmux_session"
        else
            warn "Tmux session '$tmux_session' not found (may have already exited)"
        fi
    else
        # Foreground mode - kill by PID
        local pid
        pid=$(echo "$session" | jq -r '.pid // empty')
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            kill "$pid" 2>/dev/null || true
            info "Killed process: $pid"
        else
            warn "Process not found (may have already exited)"
        fi
    fi

    # Update state to stopped
    set_session "$session_name" status="stopped" pid="" tmux_session=""

    # Send failure notification for manual stop if configured
    local notify_on_fail webhook_url project_dir iteration max_iter remaining_tasks
    project_dir=$(echo "$session" | jq -r '.dir // ""')
    iteration=$(echo "$session" | jq -r '.iteration // 0')
    max_iter=$(echo "$session" | jq -r '.max_iterations // 0')
    remaining_tasks=$(echo "$session" | jq -r '.last_task_count // 0')

    if [[ -f "$LIB_DIR/config.sh" ]]; then
        source "$LIB_DIR/config.sh"
        load_config "$project_dir"
        notify_on_fail=$(get_config "notifications.on_fail" "false")
        webhook_url=$(get_config "notifications.webhook" "")

        if [[ "$notify_on_fail" == "true" && -n "$webhook_url" ]]; then
            if [[ -f "$LIB_DIR/notify.sh" ]]; then
                source "$LIB_DIR/notify.sh"
                notify_failed "$session_name" "$webhook_url" "manual_stop" "$project_dir" \
                    "$iteration" "$max_iter" "$remaining_tasks" "" || \
                    warn "Failed to send stop notification"
            fi
        fi
    fi

    success "Stopped session: $session_name"
}

# cmd_status() - Show status of all gralph loops
# Lists all sessions in a formatted table with color coding
cmd_status() {
    # Source library files
    source_libs

    # Ensure state is initialized
    if ! init_state; then
        die "Failed to initialize state"
    fi

    # Clean up stale sessions first (remove dead sessions)
    cleanup_stale >/dev/null 2>&1

    # Get all sessions
    local sessions
    sessions=$(list_sessions)

    if [[ -z "$sessions" ]] || [[ "$sessions" == "[]" ]]; then
        info "No sessions found"
        echo ""
        echo "Start a new loop with: gralph start <directory>"
        return 0
    fi

    # Calculate column widths (minimum widths for headers)
    local name_width=8
    local dir_width=30
    local iter_width=10
    local status_width=10
    local remaining_width=10

    # Find max widths from data
    local session_count
    session_count=$(echo "$sessions" | jq -r 'length')

    for ((i=0; i<session_count; i++)); do
        local name dir
        name=$(echo "$sessions" | jq -r ".[$i].name // \"\"")
        dir=$(echo "$sessions" | jq -r ".[$i].dir // \"\"")

        # Truncate long dirs for display
        if [[ ${#dir} -gt 40 ]]; then
            dir="...${dir: -37}"
        fi

        [[ ${#name} -gt $name_width ]] && name_width=${#name}
        [[ ${#dir} -gt $dir_width ]] && dir_width=${#dir}
    done

    # Print header
    printf "${BLUE}%-${name_width}s  %-${dir_width}s  %-${iter_width}s  %-${status_width}s  %-${remaining_width}s${NC}\n" \
        "NAME" "DIR" "ITERATION" "STATUS" "REMAINING"
    printf "%-${name_width}s  %-${dir_width}s  %-${iter_width}s  %-${status_width}s  %-${remaining_width}s\n" \
        "$(printf '%*s' "$name_width" '' | tr ' ' '-')" \
        "$(printf '%*s' "$dir_width" '' | tr ' ' '-')" \
        "$(printf '%*s' "$iter_width" '' | tr ' ' '-')" \
        "$(printf '%*s' "$status_width" '' | tr ' ' '-')" \
        "$(printf '%*s' "$remaining_width" '' | tr ' ' '-')"

    # Print each session row
    for ((i=0; i<session_count; i++)); do
        local name dir iteration max_iterations status last_task_count task_file
        name=$(echo "$sessions" | jq -r ".[$i].name // \"unknown\"")
        dir=$(echo "$sessions" | jq -r ".[$i].dir // \"\"")
        iteration=$(echo "$sessions" | jq -r ".[$i].iteration // 0")
        max_iterations=$(echo "$sessions" | jq -r ".[$i].max_iterations // 0")
        status=$(echo "$sessions" | jq -r ".[$i].status // \"unknown\"")
        last_task_count=$(echo "$sessions" | jq -r ".[$i].last_task_count // \"?\"")
        task_file=$(echo "$sessions" | jq -r ".[$i].task_file // \"PRD.md\"")

        # Try to get current remaining count if directory exists
        local current_remaining="$last_task_count"
        if [[ -d "$dir" ]] && [[ -f "$dir/$task_file" ]]; then
            current_remaining=$(grep -cE '^\s*- \[ \]' "$dir/$task_file" 2>/dev/null || echo "$last_task_count")
        fi

        # Truncate long dirs for display
        local display_dir="$dir"
        if [[ ${#display_dir} -gt 40 ]]; then
            display_dir="...${display_dir: -37}"
        fi

        # Format iteration as "current/max"
        local iter_display="${iteration}/${max_iterations}"

        # Format remaining tasks
        local remaining_display
        if [[ "$current_remaining" == "0" ]]; then
            remaining_display="0 tasks"
        elif [[ "$current_remaining" == "1" ]]; then
            remaining_display="1 task"
        else
            remaining_display="${current_remaining} tasks"
        fi

        # Determine color based on status
        local status_color
        case "$status" in
            complete|completed)
                status_color="$GREEN"
                ;;
            running)
                status_color="$YELLOW"
                ;;
            failed|stale|stopped)
                status_color="$RED"
                ;;
            *)
                status_color="$NC"
                ;;
        esac

        # Print row with colored status
        printf "%-${name_width}s  %-${dir_width}s  %-${iter_width}s  ${status_color}%-${status_width}s${NC}  %-${remaining_width}s\n" \
            "$name" "$display_dir" "$iter_display" "$status" "$remaining_display"
    done

    echo ""
    echo "Commands: gralph logs <name>, gralph stop <name>, gralph resume"
}

# cmd_logs() - View logs for a gralph loop session
# Tails the log file, supports --follow flag
cmd_logs() {
    # Source library files
    source_libs

    # Ensure state is initialized
    if ! init_state; then
        die "Failed to initialize state"
    fi

    # Get session name from positional args
    local session_name="${POSITIONAL_ARGS[0]}"

    if [[ -z "$session_name" ]]; then
        die "Session name is required. Usage: gralph logs <name> [--follow]"
    fi

    # Find session by name
    local session
    if ! session=$(get_session "$session_name"); then
        die "Session not found: $session_name"
    fi

    # Get log file path
    local log_file
    log_file=$(echo "$session" | jq -r '.log_file // empty')

    if [[ -z "$log_file" ]]; then
        # Try to construct log file path from session dir
        local session_dir
        session_dir=$(echo "$session" | jq -r '.dir // empty')
        if [[ -n "$session_dir" ]]; then
            log_file="$session_dir/.gralph/gralph.log"
        fi
    fi

    if [[ -z "$log_file" ]]; then
        die "Cannot determine log file path for session: $session_name"
    fi

    if [[ ! -f "$log_file" ]]; then
        die "Log file does not exist: $log_file"
    fi

    # Display session info
    local status
    status=$(echo "$session" | jq -r '.status // "unknown"')
    info "Session: $session_name (status: $status)"
    info "Log file: $log_file"
    echo ""

    # Tail the log file
    if [[ "$OPT_FOLLOW" == "true" ]]; then
        # Follow mode - continuous tail
        tail -f "$log_file"
    else
        # Default mode - show last 100 lines
        tail -n 100 "$log_file"
    fi
}

# cmd_resume() - Resume crashed/stopped loops
# Finds sessions marked running with dead PIDs and restarts their tmux sessions
cmd_resume() {
    # Source library files
    source_libs

    # Ensure state is initialized
    if ! init_state; then
        die "Failed to initialize state"
    fi

    # Get optional session name from positional args
    local target_session="${POSITIONAL_ARGS[0]}"

    # Get all sessions
    local sessions
    sessions=$(list_sessions)

    if [[ -z "$sessions" ]] || [[ "$sessions" == "[]" ]]; then
        info "No sessions found"
        return 0
    fi

    local resumed_count=0
    local session_names

    if [[ -n "$target_session" ]]; then
        # Resume specific session
        session_names="$target_session"
    else
        # Resume all stale/stopped sessions
        session_names=$(echo "$sessions" | jq -r '.[].name // empty' 2>/dev/null)
    fi

    for session_name in $session_names; do
        local session
        if ! session=$(get_session "$session_name"); then
            if [[ -n "$target_session" ]]; then
                die "Session not found: $session_name"
            fi
            continue
        fi

        local status pid dir task_file max_iterations completion_marker backend model variant webhook iteration
        status=$(echo "$session" | jq -r '.status // "unknown"')
        pid=$(echo "$session" | jq -r '.pid // empty')
        dir=$(echo "$session" | jq -r '.dir // empty')
        task_file=$(echo "$session" | jq -r '.task_file // "PRD.md"')
        max_iterations=$(echo "$session" | jq -r '.max_iterations // 30')
        completion_marker=$(echo "$session" | jq -r '.completion_marker // "COMPLETE"')
        backend=$(echo "$session" | jq -r '.backend // "claude"')
        model=$(echo "$session" | jq -r '.model // empty')
        variant=$(echo "$session" | jq -r '.variant // empty')
        webhook=$(echo "$session" | jq -r '.webhook // empty')
        iteration=$(echo "$session" | jq -r '.iteration // 1')

        # Check if session should be resumed
        local should_resume=false

        if [[ "$status" == "running" ]]; then
            # Check if PID is dead
            if [[ -z "$pid" ]] || [[ "$pid" == "null" ]] || ! kill -0 "$pid" 2>/dev/null; then
                should_resume=true
            fi
        elif [[ "$status" == "stale" ]] || [[ "$status" == "stopped" ]]; then
            should_resume=true
        fi

        if [[ "$should_resume" != "true" ]]; then
            if [[ -n "$target_session" ]]; then
                warn "Session '$session_name' is already running (PID: $pid) or completed (status: $status)"
            fi
            continue
        fi

        # Validate directory exists
        if [[ ! -d "$dir" ]]; then
            warn "Skipping '$session_name': directory no longer exists: $dir"
            continue
        fi

        # Validate task file exists
        if [[ ! -f "$dir/$task_file" ]]; then
            warn "Skipping '$session_name': task file not found: $dir/$task_file"
            continue
        fi

        info "Resuming session: $session_name (was at iteration $iteration)"

        local tmux_session="gralph-$session_name"
        local log_file="$dir/.gralph/gralph.log"
        local gralph_dir="$dir/.gralph"

        # Ensure .gralph directory exists
        mkdir -p "$gralph_dir"

        # Get current task count
        local current_count
        current_count=$(grep -cE '^\s*- \[ \]' "$dir/$task_file" 2>/dev/null || echo "0")

        # Kill any existing tmux session with the same name
        tmux kill-session -t "$tmux_session" 2>/dev/null || true

        # Build the command to run in tmux
        local gralph_cmd="source '$LIB_DIR/state.sh' && source '$LIB_DIR/backends/common.sh' && source '$LIB_DIR/core.sh' && "
        gralph_cmd+="export GRALPH_BACKEND='$backend' && "
        if [[ -n "$variant" ]]; then
            gralph_cmd+="export GRALPH_VARIANT='$variant' && "
        fi
        gralph_cmd+="init_backend '$backend' && "
        gralph_cmd+="GRALPH_STATE_CALLBACK=_update_session_state "
        gralph_cmd+="_update_session_state() { "
        gralph_cmd+="  set_session \"\$1\" iteration=\"\$2\" status=\"\$3\" last_task_count=\"\$4\"; "
        gralph_cmd+="}; "
        gralph_cmd+="run_loop "
        gralph_cmd+="'$dir' "
        gralph_cmd+="'$task_file' "
        gralph_cmd+="'$max_iterations' "
        gralph_cmd+="'$completion_marker' "
        gralph_cmd+="'$model' "
        gralph_cmd+="'$session_name'; "
        gralph_cmd+="exit_code=\$?; "
        gralph_cmd+="if [ \$exit_code -eq 0 ]; then "
        gralph_cmd+="  set_session '$session_name' status=complete; "
        gralph_cmd+="else "
        gralph_cmd+="  set_session '$session_name' status=failed; "
        gralph_cmd+="fi"

        # Start tmux session
        tmux new-session -d -s "$tmux_session" bash -lc "$gralph_cmd"

        # Get the PID of the tmux session's shell
        local tmux_pid
        tmux_pid=$(tmux list-panes -t "$tmux_session" -F '#{pane_pid}' 2>/dev/null | head -1)

        # Update state with new PID and status
        set_session "$session_name" \
            "pid=$tmux_pid" \
            "tmux_session=$tmux_session" \
            "status=running" \
            "last_task_count=$current_count"

        resumed_count=$((resumed_count + 1))
        success "Resumed session: $session_name in tmux session: $tmux_session"
    done

    if [[ $resumed_count -eq 0 ]]; then
        info "No sessions to resume"
    else
        echo ""
        success "Resumed $resumed_count session(s)"
        echo ""
        echo "Commands: gralph status, gralph logs <name>, gralph stop <name>"
    fi
}

cmd_backends() {
    # Source library files
    source_libs

    echo "Available AI backends:"
    echo ""

    local backends
    backends=$(list_available_backends)

    for backend in $backends; do
        echo -n "  $backend"

        # Try to load backend to check if installed
        if load_backend "$backend" 2>/dev/null; then
            if backend_check_installed; then
                echo -e " ${GREEN}(installed)${NC}"
                echo "      Models: $(backend_get_models)"
            else
                echo -e " ${YELLOW}(not installed)${NC}"
                echo "      Install: $(backend_get_install_hint)"
            fi
        else
            echo -e " ${RED}(error loading)${NC}"
        fi
        echo ""
    done

    echo "Usage: gralph start <dir> --backend <name>"
}

cmd_config() {
    # Source configuration library
    if [[ -f "$LIB_DIR/config.sh" ]]; then
        source "$LIB_DIR/config.sh"
    else
        die "Library not found: $LIB_DIR/config.sh"
    fi

    local subcommand="${POSITIONAL_ARGS[0]}"

    case "$subcommand" in
        get)
            local key="${POSITIONAL_ARGS[1]}"
            if [[ -z "$key" ]]; then
                die "Usage: gralph config get <key>"
            fi

            load_config "$(pwd)"
            if config_exists "$key"; then
                get_config "$key"
            else
                die "Config key not found: $key"
            fi
            ;;
        set)
            local key="${POSITIONAL_ARGS[1]}"
            local value="${POSITIONAL_ARGS[2]}"
            if [[ -z "$key" || -z "$value" ]]; then
                die "Usage: gralph config set <key> <value>"
            fi

            if set_config "$key" "$value"; then
                success "Updated config: $key"
            else
                die "Failed to set config: $key"
            fi
            ;;
        list|"" )
            load_config "$(pwd)"
            list_config
            ;;
        *)
            die "Unknown config command: $subcommand. Use 'gralph config get <key>' or 'gralph config set <key> <value>'"
            ;;
    esac
}

cmd_server() {
    # Source server library
    if [[ -f "$LIB_DIR/server.sh" ]]; then
        source "$LIB_DIR/state.sh"
        source "$LIB_DIR/server.sh"
    else
        die "Library not found: $LIB_DIR/server.sh"
    fi

    # Get port and token from parsed options
    local port="${OPT_PORT:-8080}"
    local token="${OPT_TOKEN:-}"

    # Start the server
    start_server "$port" "$token"
}

cmd_version() {
    echo "gralph v$VERSION"
}

# Main entry point
main() {
    parse_args "$@"

    case "$COMMAND" in
        start)
            cmd_start
            ;;
        stop)
            cmd_stop
            ;;
        status)
            cmd_status
            ;;
        logs)
            cmd_logs
            ;;
        resume)
            cmd_resume
            ;;
        backends)
            cmd_backends
            ;;
        config)
            cmd_config
            ;;
        server)
            cmd_server
            ;;
        version|--version|-v)
            cmd_version
            ;;
        help|--help|-h)
            usage
            ;;
        "")
            usage
            ;;
        *)
            die "Unknown command: $COMMAND. Run 'gralph help' for usage."
            ;;
    esac
}

main "$@"
