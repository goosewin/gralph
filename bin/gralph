#!/usr/bin/env bash
# gralph - Autonomous AI coding loops
# Version: 1.1.0

set -e

VERSION="1.1.0"

# Ensure bash 4+ for associative arrays
if [[ -n "${BASH_VERSINFO[0]:-}" ]] && ((BASH_VERSINFO[0] < 4)); then
  echo "Error: gralph requires bash 4+ (found ${BASH_VERSINFO[0]})." >&2
  echo "Install a newer bash and run with it, for example:" >&2
  echo "  brew install bash" >&2
  echo "  $(brew --prefix 2>/dev/null)/bin/bash $(command -v gralph) <args>" >&2
  exit 1
fi

# Determine script and library directories
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LIB_DIR="${SCRIPT_DIR}/../lib"

# Alternative lib location when installed
# Prefer fallback if the expected library files are missing
if [[ ! -f "$LIB_DIR/state.sh" ]] && [[ -d "${HOME}/.config/gralph/lib" ]]; then
  LIB_DIR="${HOME}/.config/gralph/lib"
fi

# Default configuration values
DEFAULT_MAX_ITERATIONS=30
DEFAULT_TASK_FILE="PRD.md"
DEFAULT_COMPLETION_MARKER="COMPLETE"
DEFAULT_MODEL=""
DEFAULT_VARIANT=""

# ANSI color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Print usage information
usage() {
  cat <<'EOF'
  ___  ____    __    __    ____  _   _
 / __)(  _ \  /__\  (  )  (  _ \( )_( )
( (_-. )   / /(__)\  )(__  )___/ ) _ (
 \___/(_)\_)(__)(__)(____)(__)  (_) (_)

gralph - Autonomous AI coding loops

USAGE:
  gralph <command> [options]

COMMANDS:
  start <dir>         Start a new gralph loop
  stop <name>         Stop a running loop
  stop --all          Stop all loops
  status              Show status of all loops
  logs <name>         View logs for a loop
  resume [name]       Resume crashed/stopped loops
  prd check <file>    Validate PRD task blocks
  prd create          Generate a spec-compliant PRD
  worktree create <ID> Create task worktree
  worktree finish <ID> Finish task worktree
  backends            List available AI backends
  config              Manage configuration
  server              Start status API server
  version             Show version
  help                Show this help message

START OPTIONS:
  --name, -n          Session name (default: directory name)
  --max-iterations    Max iterations before giving up (default: 30)
  --task-file, -f     Task file path (default: PRD.md)
  --completion-marker Completion promise text (default: COMPLETE)
  --backend, -b       AI backend (default: claude). See `gralph backends`
  --model, -m         Model override (format depends on backend)
  --variant           Model variant override (backend-specific)
  --prompt-template   Path to custom prompt template file
  --webhook           Notification webhook URL
  --no-tmux           Run in foreground (blocks)
  --strict-prd        Validate PRD before starting the loop

PRD OPTIONS:
  --dir               Project directory (default: current)
  --output, -o        Output PRD file path (default: PRD.generated.md)
  --goal              Short description of what to build
  --constraints       Constraints or non-functional requirements
  --context           Extra context files (comma-separated)
  --sources           External URLs or references (comma-separated)
  --backend, -b        Backend for PRD generation (default: config/default)
  --model, -m          Model override for PRD generation
  --allow-missing-context Allow missing Context Bundle paths
  --multiline         Enable multiline prompts (interactive)
  --no-interactive    Disable interactive prompts
  --interactive       Force interactive prompts
  --force             Overwrite existing output file

SERVER OPTIONS:
  --host, -H            Host/IP to bind to (default: 127.0.0.1)
  --port, -p            Port number (default: 8080)
  --token, -t           Authentication token (required for non-localhost)
  --open                Disable token requirement (use with caution)

EXAMPLES:
  gralph start .
  gralph start ~/project --name myapp --max-iterations 50
  gralph status
  gralph logs myapp --follow
  gralph stop myapp
  gralph prd create --dir . --output PRD.new.md --goal "Add a billing dashboard"
  gralph worktree create C-1
  gralph worktree finish C-1
  gralph server --host 0.0.0.0 --port 8080
EOF
}

# Print error message and exit
die() {
  echo -e "${RED}Error:${NC} $1" >&2
  exit 1
}

# Print warning message
warn() {
  echo -e "${YELLOW}Warning:${NC} $1" >&2
}

# Print info message
info() {
  echo -e "${BLUE}Info:${NC} $1"
}

# Print success message
success() {
  echo -e "${GREEN}Success:${NC} $1"
}

# Ensure git working tree is clean
ensure_git_clean() {
  local repo_root="$1"
  local status_output
  if ! status_output=$(git -C "$repo_root" status --porcelain 2>/dev/null); then
    die "Unable to check git status in $repo_root"
  fi
  if [[ -n "$status_output" ]]; then
    die "Git working tree is dirty. Commit or stash changes before running worktree commands."
  fi
}

# Escape a string for safe inclusion in single-quoted shell arguments
# This replaces ' with '\'' (end quote, escaped quote, start quote)
escape_single_quote() {
  local str="$1"
  printf '%s' "${str//\'/\'\\\'\'}"
}

prompt_input() {
  local prompt="$1"
  local default_value="$2"
  local input=""

  if [[ -n "$default_value" ]]; then
    printf "%s [%s]: " "$prompt" "$default_value" >&2
  else
    printf "%s: " "$prompt" >&2
  fi

  if ! IFS= read -r input; then
    input=""
  fi

  if [[ -z "$input" ]]; then
    input="$default_value"
  fi

  printf '%s' "$input"
}

prompt_multiline() {
  local prompt="$1"
  local line=""
  local lines=()

  printf "%s (finish with empty line):\n" "$prompt" >&2
  while true; do
    if ! IFS= read -r line; then
      break
    fi
    if [[ -z "$line" ]]; then
      break
    fi
    lines+=("$line")
  done

  if [[ ${#lines[@]} -eq 0 ]]; then
    return 0
  fi

  printf '%s\n' "${lines[@]}"
}

build_context_file_list() {
  local target_dir="$1"
  local user_list="$2"
  local config_list="$3"
  local entry=""
  local normalized=()
  local -A seen

  add_context_entry() {
    local item="$1"
    local resolved=""
    local display=""

    if [[ -z "$item" ]]; then
      return 0
    fi

    if [[ "$item" != /* ]]; then
      resolved="$target_dir/$item"
    else
      resolved="$item"
    fi

    if [[ ! -f "$resolved" ]]; then
      return 0
    fi

    if [[ "$resolved" == "$target_dir"/* ]]; then
      display="${resolved#"$target_dir/"}"
    else
      display="$resolved"
    fi

    if [[ -z "${seen[$display]:-}" ]]; then
      seen[$display]=1
      normalized+=("$display")
    fi
  }

  if [[ -n "$config_list" ]]; then
    IFS=',' read -r -a _config_entries <<<"$config_list"
    for entry in "${_config_entries[@]}"; do
      entry="${entry#"${entry%%[![:space:]]*}"}"
      entry="${entry%"${entry##*[![:space:]]}"}"
      add_context_entry "$entry"
    done
  fi

  if [[ -n "$user_list" ]]; then
    IFS=',' read -r -a _user_entries <<<"$user_list"
    for entry in "${_user_entries[@]}"; do
      entry="${entry#"${entry%%[![:space:]]*}"}"
      entry="${entry%"${entry##*[![:space:]]}"}"
      add_context_entry "$entry"
    done
  fi

    add_context_entry "README.md"
    add_context_entry "ARCHITECTURE.md"
    add_context_entry "DECISIONS.md"
  add_context_entry "CHANGELOG.md"
  add_context_entry "RISK_REGISTER.md"
  add_context_entry "PROCESS.md"
  add_context_entry "PRD.template.md"
  add_context_entry "bin/gralph"
  add_context_entry "config/default.yaml"
  add_context_entry "opencode.json"
  add_context_entry "completions/gralph.bash"
  add_context_entry "completions/gralph.zsh"

  local candidate
  for candidate in "$target_dir"/lib/*.sh "$target_dir"/lib/backends/*.sh; do
    if [[ -f "$candidate" ]]; then
      add_context_entry "${candidate#"$target_dir/"}"
    fi
  done

  for candidate in "$target_dir"/tests/*.sh; do
    if [[ -f "$candidate" ]]; then
      add_context_entry "${candidate#"$target_dir/"}"
    fi
  done

  if [[ ${#normalized[@]} -eq 0 ]]; then
    return 0
  fi

  printf '%s\n' "${normalized[@]}"
}

trim_whitespace() {
  local value="$1"
  value="${value#"${value%%[![:space:]]*}"}"
  value="${value%"${value##*[![:space:]]}"}"
  printf '%s' "$value"
}

normalize_csv_list() {
  local raw="$1"
  local entry
  local -a items=()

  if [[ -z "$raw" ]]; then
    return 0
  fi

  IFS=',' read -r -a _entries <<<"$raw"
  for entry in "${_entries[@]}"; do
    entry=$(trim_whitespace "$entry")
    if [[ -n "$entry" ]]; then
      items+=("$entry")
    fi
  done

  if [[ ${#items[@]} -gt 0 ]]; then
    printf '%s\n' "${items[@]}"
  fi
}

dedupe_list() {
  local -A seen
  local -a output=()
  local item

  for item in "$@"; do
    if [[ -z "$item" ]]; then
      continue
    fi
    if [[ -z "${seen[$item]:-}" ]]; then
      seen[$item]=1
      output+=("$item")
    fi
  done

  if [[ ${#output[@]} -gt 0 ]]; then
    printf '%s\n' "${output[@]}"
  fi
}

collect_official_sources() {
  local -a sources=()
  local item

  for item in "${PRD_STACK_SELECTED_IDS[@]}"; do
    case "$item" in
    "Node.js") sources+=("https://nodejs.org/docs/latest/api/") ;;
    "Go") sources+=("https://go.dev/doc/") ;;
    "Rust") sources+=("https://doc.rust-lang.org/") ;;
    "Python") sources+=("https://docs.python.org/3/") ;;
    "Ruby") sources+=("https://www.ruby-lang.org/en/documentation/") ;;
    "Java") sources+=("https://docs.oracle.com/en/java/") ;;
    ".NET") sources+=("https://learn.microsoft.com/dotnet/") ;;
    "PHP") sources+=("https://www.php.net/manual/en/") ;;
    "Elixir") sources+=("https://elixir-lang.org/docs.html") ;;
    esac
  done

  for item in "${PRD_STACK_FRAMEWORKS[@]}"; do
    case "$item" in
    "React") sources+=("https://react.dev/") ;;
    "Next.js") sources+=("https://nextjs.org/docs") ;;
    "Vue") sources+=("https://vuejs.org/guide/") ;;
    "Angular") sources+=("https://angular.dev/guide") ;;
    "Svelte") sources+=("https://svelte.dev/docs") ;;
    "Nuxt") sources+=("https://nuxt.com/docs") ;;
    "Express") sources+=("https://expressjs.com/") ;;
    "Fastify") sources+=("https://www.fastify.io/docs/latest/") ;;
    "NestJS") sources+=("https://docs.nestjs.com/") ;;
    "Django") sources+=("https://docs.djangoproject.com/en/stable/") ;;
    "Flask") sources+=("https://flask.palletsprojects.com/") ;;
    "FastAPI") sources+=("https://fastapi.tiangolo.com/") ;;
    "Rails") sources+=("https://guides.rubyonrails.org/") ;;
    "Sinatra") sources+=("https://sinatrarb.com/documentation.html") ;;
    "Phoenix") sources+=("https://hexdocs.pm/phoenix/") ;;
    "Laravel") sources+=("https://laravel.com/docs") ;;
    "Spring Boot") sources+=("https://docs.spring.io/spring-boot/docs/current/reference/html/") ;;
    esac
  done

  for item in "${PRD_STACK_TOOLS[@]}"; do
    case "$item" in
    "Vite") sources+=("https://vitejs.dev/guide/") ;;
    "Docker") sources+=("https://docs.docker.com/") ;;
    "Docker Compose") sources+=("https://docs.docker.com/compose/") ;;
    "Make") sources+=("https://www.gnu.org/software/make/manual/make.html") ;;
    "Terraform") sources+=("https://developer.hashicorp.com/terraform/docs") ;;
    "Go modules") sources+=("https://go.dev/ref/mod") ;;
    "Cargo") sources+=("https://doc.rust-lang.org/cargo/") ;;
    "Maven") sources+=("https://maven.apache.org/guides/") ;;
    "Gradle") sources+=("https://docs.gradle.org/current/userguide/userguide.html") ;;
    "Poetry") sources+=("https://python-poetry.org/docs/") ;;
    esac
  done

  for item in "${PRD_STACK_PACKAGE_MANAGERS[@]}"; do
    case "$item" in
    "pnpm") sources+=("https://pnpm.io/") ;;
    "yarn") sources+=("https://yarnpkg.com/") ;;
    "npm") sources+=("https://docs.npmjs.com/") ;;
    "bun") sources+=("https://bun.sh/docs") ;;
    esac
  done

  if [[ ${#sources[@]} -gt 0 ]]; then
    printf '%s\n' "${sources[@]}"
  fi
}

search_web_sources() {
  local query="$1"
  local max_results="${2:-5}"
  local encoded
  local url
  local html
  local urls
  local -a results=()
  local line

  if [[ -z "$query" ]]; then
    return 0
  fi

  if ! command -v curl >/dev/null 2>&1; then
    return 0
  fi

  encoded="${query// /+}"
  url="https://lite.duckduckgo.com/lite/?q=${encoded}"
  html=$(curl -fsSL --max-time 8 "$url" 2>/dev/null || true)

  if [[ -z "$html" ]]; then
    return 0
  fi

  urls=$(printf '%s' "$html" | grep -Eo 'https?://[^" ]+' || true)
  while IFS= read -r line; do
    if [[ -z "$line" ]]; then
      continue
    fi
    if [[ "$line" == *"duckduckgo.com"* ]]; then
      continue
    fi
    results+=("$line")
    if [[ ${#results[@]} -ge "$max_results" ]]; then
      break
    fi
  done <<<"$urls"

  if [[ ${#results[@]} -gt 0 ]]; then
    printf '%s\n' "${results[@]}"
  fi
}

get_prd_template_text() {
  local target_dir="$1"
  local candidate

  for candidate in "$target_dir/PRD.template.md" "$SCRIPT_DIR/../PRD.template.md"; do
    if [[ -f "$candidate" ]]; then
      cat "$candidate"
      return 0
    fi
  done

  cat <<'EOF'
## Overview

Briefly describe the project, goals, and intended users.

## Problem Statement

- What problem does this solve?
- What pain points exist today?

## Solution

High-level solution summary.

---

## Functional Requirements

### FR-1: Core Feature

Describe the primary user-facing behavior.

### FR-2: Secondary Feature

Describe supporting behavior.

---

## Non-Functional Requirements

### NFR-1: Performance

- Example: Response times under 200ms for key operations.

### NFR-2: Reliability

- Example: Crash recovery or retries where appropriate.

---

## Implementation Tasks

Each task must use a `### Task <ID>` block header and include the required fields.
Each task block must contain exactly one unchecked task line.

### Task EX-1

- **ID** EX-1
- **Context Bundle** `path/to/file`, `path/to/other`
- **DoD** Define the done criteria for this task.
- **Checklist**
  * First verification item.
  * Second verification item.
- **Dependencies** None
- [ ] EX-1 Short task summary

---

## Success Criteria

- Define measurable outcomes that indicate completion.

---

## Sources

- List authoritative URLs used as source of truth.

---

## Warnings

- Only include this section if no reliable sources were found.
- State what is missing and what must be verified.
EOF
}

# Parse command line arguments
# Sets global variables based on parsed arguments
parse_args() {
  # Global argument storage
  COMMAND=""
  POSITIONAL_ARGS=()

  # Start command options
  OPT_NAME=""
  OPT_MAX_ITERATIONS="$DEFAULT_MAX_ITERATIONS"
  OPT_TASK_FILE="$DEFAULT_TASK_FILE"
  OPT_COMPLETION_MARKER="$DEFAULT_COMPLETION_MARKER"
  OPT_BACKEND=""
  OPT_MODEL="$DEFAULT_MODEL"
  OPT_VARIANT="${GRALPH_VARIANT:-$DEFAULT_VARIANT}"
  OPT_PROMPT_TEMPLATE_FILE=""
  OPT_WEBHOOK=""
  OPT_NO_TMUX=false
  OPT_STRICT_PRD=false
  OPT_PRD_OUTPUT=""
  OPT_PRD_DIR=""
  OPT_PRD_GOAL=""
  OPT_PRD_CONSTRAINTS=""
  OPT_PRD_CONTEXT=""
  OPT_PRD_SOURCES=""
  OPT_PRD_ALLOW_MISSING_CONTEXT=false
  OPT_PRD_MULTILINE=false
  OPT_PRD_FORCE=false
  OPT_PRD_INTERACTIVE=true
  OPT_PRD_INTERACTIVE_SET=false

  OPT_NAME_SET=false
  OPT_MAX_ITERATIONS_SET=false
  OPT_TASK_FILE_SET=false
  OPT_COMPLETION_MARKER_SET=false
  OPT_BACKEND_SET=false
  OPT_MODEL_SET=false
  OPT_VARIANT_SET=false
  OPT_PROMPT_TEMPLATE_FILE_SET=false
  OPT_WEBHOOK_SET=false
  OPT_NO_TMUX_SET=false

  # Stop command options
  OPT_ALL=false

  # Logs command options
  OPT_FOLLOW=false

  # Server command options
  OPT_PORT=""
  OPT_HOST=""
  OPT_TOKEN=""
  OPT_OPEN=false

  # No arguments provided
  if [[ $# -eq 0 ]]; then
    usage
    exit 0
  fi

  # First argument is the command
  COMMAND="$1"
  shift

  # Parse remaining arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
    # Help flags
    -h | --help)
      usage
      exit 0
      ;;

    # Name option (start command)
    -n | --name)
      if [[ -z "$2" ]] || [[ "$2" == -* ]]; then
        die "Option --name requires a value"
      fi
      OPT_NAME="$2"
      OPT_NAME_SET=true
      shift 2
      ;;
    --name=*)
      OPT_NAME="${1#*=}"
      OPT_NAME_SET=true
      shift
      ;;

    # Max iterations option (start command)
    --max-iterations)
      if [[ -z "$2" ]] || [[ "$2" == -* ]]; then
        die "Option --max-iterations requires a value"
      fi
      if ! [[ "$2" =~ ^[0-9]+$ ]]; then
        die "Option --max-iterations must be a positive integer"
      fi
      OPT_MAX_ITERATIONS="$2"
      OPT_MAX_ITERATIONS_SET=true
      shift 2
      ;;
    --max-iterations=*)
      local val="${1#*=}"
      if ! [[ "$val" =~ ^[0-9]+$ ]]; then
        die "Option --max-iterations must be a positive integer"
      fi
      OPT_MAX_ITERATIONS="$val"
      OPT_MAX_ITERATIONS_SET=true
      shift
      ;;

    # Task file option (start command)
    -f | --task-file)
      if [[ -z "$2" ]] || [[ "$2" == -* ]]; then
        die "Option --task-file requires a value"
      fi
      OPT_TASK_FILE="$2"
      OPT_TASK_FILE_SET=true
      shift 2
      ;;
    --task-file=*)
      OPT_TASK_FILE="${1#*=}"
      OPT_TASK_FILE_SET=true
      shift
      ;;

    # Completion marker option (start command)
    --completion-marker)
      if [[ -z "$2" ]] || [[ "$2" == -* ]]; then
        die "Option --completion-marker requires a value"
      fi
      OPT_COMPLETION_MARKER="$2"
      OPT_COMPLETION_MARKER_SET=true
      shift 2
      ;;
    --completion-marker=*)
      OPT_COMPLETION_MARKER="${1#*=}"
      OPT_COMPLETION_MARKER_SET=true
      shift
      ;;

    # Backend option (start command)
    -b | --backend)
      if [[ -z "$2" ]] || [[ "$2" == -* ]]; then
        die "Option --backend requires a value"
      fi
      OPT_BACKEND="$2"
      OPT_BACKEND_SET=true
      shift 2
      ;;
    --backend=*)
      local val="${1#*=}"
      OPT_BACKEND="$val"
      OPT_BACKEND_SET=true
      shift
      ;;

    # Model option (start command)
    -m | --model)
      if [[ -z "$2" ]] || [[ "$2" == -* ]]; then
        die "Option --model requires a value"
      fi
      OPT_MODEL="$2"
      OPT_MODEL_SET=true
      shift 2
      ;;
    --model=*)
      OPT_MODEL="${1#*=}"
      OPT_MODEL_SET=true
      shift
      ;;

    # Variant option (start command)
    --variant)
      if [[ -z "$2" ]] || [[ "$2" == -* ]]; then
        die "Option --variant requires a value"
      fi
      OPT_VARIANT="$2"
      OPT_VARIANT_SET=true
      shift 2
      ;;
    --variant=*)
      OPT_VARIANT="${1#*=}"
      OPT_VARIANT_SET=true
      shift
      ;;

    # Prompt template option (start command)
    --prompt-template)
      if [[ -z "$2" ]] || [[ "$2" == -* ]]; then
        die "Option --prompt-template requires a file path"
      fi
      OPT_PROMPT_TEMPLATE_FILE="$2"
      OPT_PROMPT_TEMPLATE_FILE_SET=true
      shift 2
      ;;
    --prompt-template=*)
      OPT_PROMPT_TEMPLATE_FILE="${1#*=}"
      OPT_PROMPT_TEMPLATE_FILE_SET=true
      shift
      ;;

    # Webhook option (start command)
    --webhook)
      if [[ -z "$2" ]] || [[ "$2" == -* ]]; then
        die "Option --webhook requires a value"
      fi
      OPT_WEBHOOK="$2"
      OPT_WEBHOOK_SET=true
      shift 2
      ;;
    --webhook=*)
      OPT_WEBHOOK="${1#*=}"
      OPT_WEBHOOK_SET=true
      shift
      ;;

    # No tmux flag (start command)
    --no-tmux)
      OPT_NO_TMUX=true
      OPT_NO_TMUX_SET=true
      shift
      ;;

    # Strict PRD validation flag (start command)
    --strict-prd)
      OPT_STRICT_PRD=true
      shift
      ;;

    # PRD generator options
    --dir)
      if [[ -z "$2" ]] || [[ "$2" == -* ]]; then
        die "Option --dir requires a value"
      fi
      OPT_PRD_DIR="$2"
      shift 2
      ;;
    --dir=*)
      OPT_PRD_DIR="${1#*=}"
      shift
      ;;
    --output | -o)
      if [[ -z "$2" ]] || [[ "$2" == -* ]]; then
        die "Option --output requires a value"
      fi
      OPT_PRD_OUTPUT="$2"
      shift 2
      ;;
    --output=*)
      OPT_PRD_OUTPUT="${1#*=}"
      shift
      ;;
    --goal)
      if [[ -z "$2" ]] || [[ "$2" == -* ]]; then
        die "Option --goal requires a value"
      fi
      OPT_PRD_GOAL="$2"
      shift 2
      ;;
    --goal=*)
      OPT_PRD_GOAL="${1#*=}"
      shift
      ;;
    --constraints)
      if [[ -z "$2" ]] || [[ "$2" == -* ]]; then
        die "Option --constraints requires a value"
      fi
      OPT_PRD_CONSTRAINTS="$2"
      shift 2
      ;;
    --constraints=*)
      OPT_PRD_CONSTRAINTS="${1#*=}"
      shift
      ;;
    --context)
      if [[ -z "$2" ]] || [[ "$2" == -* ]]; then
        die "Option --context requires a value"
      fi
      OPT_PRD_CONTEXT="$2"
      shift 2
      ;;
    --context=*)
      OPT_PRD_CONTEXT="${1#*=}"
      shift
      ;;
    --sources)
      if [[ -z "$2" ]] || [[ "$2" == -* ]]; then
        die "Option --sources requires a value"
      fi
      OPT_PRD_SOURCES="$2"
      shift 2
      ;;
    --sources=*)
      OPT_PRD_SOURCES="${1#*=}"
      shift
      ;;
    --allow-missing-context)
      OPT_PRD_ALLOW_MISSING_CONTEXT=true
      shift
      ;;
    --multiline)
      OPT_PRD_MULTILINE=true
      shift
      ;;
    --no-interactive | --non-interactive)
      OPT_PRD_INTERACTIVE=false
      OPT_PRD_INTERACTIVE_SET=true
      shift
      ;;
    --interactive)
      OPT_PRD_INTERACTIVE=true
      OPT_PRD_INTERACTIVE_SET=true
      shift
      ;;
    --force)
      OPT_PRD_FORCE=true
      shift
      ;;

    # All flag (stop command)
    --all | -a)
      OPT_ALL=true
      shift
      ;;

    # Follow flag (logs command)
    --follow)
      OPT_FOLLOW=true
      shift
      ;;

    # Port option (server command)
    --port | -p)
      if [[ -z "$2" ]] || [[ "$2" == -* ]]; then
        die "Option --port requires a value"
      fi
      if ! [[ "$2" =~ ^[0-9]+$ ]]; then
        die "Option --port must be a positive integer"
      fi
      OPT_PORT="$2"
      shift 2
      ;;
    --port=*)
      local val="${1#*=}"
      if ! [[ "$val" =~ ^[0-9]+$ ]]; then
        die "Option --port must be a positive integer"
      fi
      OPT_PORT="$val"
      shift
      ;;

    # Host option (server command)
    --host | -H)
      if [[ -z "$2" ]] || [[ "$2" == -* ]]; then
        die "Option --host requires a value"
      fi
      OPT_HOST="$2"
      shift 2
      ;;
    --host=*)
      OPT_HOST="${1#*=}"
      shift
      ;;

    # Token option (server command)
    --token | -t)
      if [[ -z "$2" ]] || [[ "$2" == -* ]]; then
        die "Option --token requires a value"
      fi
      OPT_TOKEN="$2"
      shift 2
      ;;
    --token=*)
      OPT_TOKEN="${1#*=}"
      shift
      ;;

    # Open flag (server command) - disable security requirement
    --open)
      OPT_OPEN=true
      shift
      ;;

    # Unknown option
    -*)
      die "Unknown option: $1"
      ;;

    # Positional argument
    *)
      POSITIONAL_ARGS+=("$1")
      shift
      ;;
    esac
  done
}

# Source library files
source_libs() {
  if [[ -f "$LIB_DIR/state.sh" ]]; then
    source "$LIB_DIR/state.sh"
  else
    die "Library not found: $LIB_DIR/state.sh"
  fi
  if [[ -f "$LIB_DIR/backends/common.sh" ]]; then
    source "$LIB_DIR/backends/common.sh"
  else
    die "Library not found: $LIB_DIR/backends/common.sh"
  fi
  if [[ -f "$LIB_DIR/core.sh" ]]; then
    source "$LIB_DIR/core.sh"
  else
    die "Library not found: $LIB_DIR/core.sh"
  fi
}

# cmd_start() - Start a new gralph loop
# Validates inputs, creates tmux session, and saves state
cmd_start() {
  # Get directory from positional args
  local target_dir="${POSITIONAL_ARGS[0]}"

  if [[ -z "$target_dir" ]]; then
    die "Directory is required. Usage: gralph start <directory>"
  fi

  # Validate directory exists
  if [[ ! -d "$target_dir" ]]; then
    die "Directory does not exist: $target_dir"
  fi

  # Resolve to absolute path
  target_dir=$(cd "$target_dir" && pwd)

  # Load configuration defaults (if available) for this project
  if [[ -f "$LIB_DIR/config.sh" ]]; then
    source "$LIB_DIR/config.sh"
    load_config "$target_dir"

    if [[ "$OPT_MAX_ITERATIONS_SET" != "true" ]]; then
      OPT_MAX_ITERATIONS=$(get_config "defaults.max_iterations" "$OPT_MAX_ITERATIONS")
    fi
    if [[ "$OPT_TASK_FILE_SET" != "true" ]]; then
      OPT_TASK_FILE=$(get_config "defaults.task_file" "$OPT_TASK_FILE")
    fi
    if [[ "$OPT_COMPLETION_MARKER_SET" != "true" ]]; then
      OPT_COMPLETION_MARKER=$(get_config "defaults.completion_marker" "$OPT_COMPLETION_MARKER")
    fi
    if [[ "$OPT_BACKEND_SET" != "true" ]]; then
      OPT_BACKEND=$(get_config "defaults.backend" "$OPT_BACKEND")
    fi
    if [[ "$OPT_MODEL_SET" != "true" ]]; then
      OPT_MODEL=$(get_config "defaults.model" "$OPT_MODEL")
    fi
    if [[ -z "$OPT_MODEL" ]] && [[ "${OPT_BACKEND:-claude}" == "opencode" ]]; then
      OPT_MODEL=$(get_config "opencode.default_model" "$OPT_MODEL")
    fi
  fi

  # Validate configured values
  if ! [[ "$OPT_MAX_ITERATIONS" =~ ^[0-9]+$ ]]; then
    die "Configured max_iterations must be a positive integer"
  fi
  if [[ -z "$OPT_COMPLETION_MARKER" ]]; then
    die "Configured completion marker cannot be empty"
  fi

  # Validate task file exists
  local task_file_path="$target_dir/$OPT_TASK_FILE"
  if [[ ! -f "$task_file_path" ]]; then
    die "Task file does not exist: $task_file_path"
  fi

  if [[ "$OPT_STRICT_PRD" == "true" ]]; then
    if [[ -f "$LIB_DIR/prd.sh" ]]; then
      source "$LIB_DIR/prd.sh"
    else
      die "Library not found: $LIB_DIR/prd.sh"
    fi

    if ! prd_validate_file "$task_file_path"; then
      die "PRD validation failed: $task_file_path"
    fi
  fi

  # Determine session name (default to directory basename)
  local session_name="${OPT_NAME:-$(basename "$target_dir")}"

  # Sanitize session name for tmux (replace invalid chars with -)
  session_name=$(echo "$session_name" | sed 's/[^a-zA-Z0-9_-]/-/g')

  # Source library files
  source_libs

  # Initialize state
  if ! init_state; then
    die "Failed to initialize state"
  fi

  # Check for existing session with same name
  if get_session "$session_name" >/dev/null 2>&1; then
    local existing_status
    existing_status=$(get_session "$session_name" | jq -r '.status // "unknown"')
    if [[ "$existing_status" == "running" ]]; then
      # Check if the PID is actually alive
      local existing_pid
      existing_pid=$(get_session "$session_name" | jq -r '.pid // ""')
      if [[ -n "$existing_pid" ]] && kill -0 "$existing_pid" 2>/dev/null; then
        die "Session '$session_name' is already running (PID: $existing_pid). Use 'gralph stop $session_name' first."
      else
        warn "Session '$session_name' exists but appears stale. Restarting..."
      fi
    fi
  fi

  # Create .gralph directory in project
  local gralph_dir="$target_dir/.gralph"
  mkdir -p "$gralph_dir"

  local log_file="$gralph_dir/${session_name}.log"
  local tmux_session="gralph-$session_name"

  # Handle prompt template file (optional)
  if [[ -n "$OPT_PROMPT_TEMPLATE_FILE" ]]; then
    local prompt_template_file="$OPT_PROMPT_TEMPLATE_FILE"

    if [[ "$prompt_template_file" != /* ]]; then
      prompt_template_file="$(pwd)/$prompt_template_file"
    fi

    if [[ ! -f "$prompt_template_file" ]]; then
      die "Prompt template file does not exist: $prompt_template_file"
    fi

    if ! cp "$prompt_template_file" "$gralph_dir/prompt-template.txt"; then
      die "Failed to copy prompt template to $gralph_dir/prompt-template.txt"
    fi
  fi

  # Get initial task count
  local initial_count
  initial_count=$(grep -cE '^\s*- \[ \]' "$task_file_path" 2>/dev/null || true)

  # Determine backend (CLI option > config > default)
  local backend="${OPT_BACKEND:-claude}"

  # Validate backend exists in available implementations
  if [[ -f "$LIB_DIR/backends/common.sh" ]]; then
    source "$LIB_DIR/backends/common.sh"
    local available_backends
    local backend_found=false
    available_backends=$(list_available_backends)
    for item in $available_backends; do
      if [[ "$item" == "$backend" ]]; then
        backend_found=true
        break
      fi
    done
    if [[ "$backend_found" != "true" ]]; then
      die "Unknown backend: $backend. Available backends: $available_backends"
    fi
  fi

  # Initialize and validate backend
  if ! init_backend "$backend"; then
    die "Failed to initialize backend: $backend"
  fi

  info "Starting gralph loop..."
  info "  Directory: $target_dir"
  info "  Session: $session_name"
  info "  Task file: $OPT_TASK_FILE"
  info "  Max iterations: $OPT_MAX_ITERATIONS"
  info "  Completion marker: $OPT_COMPLETION_MARKER"
  info "  Backend: $backend"
  info "  Remaining tasks: $initial_count"
  if [[ -n "$OPT_PROMPT_TEMPLATE_FILE" ]]; then
    info "  Prompt template: $gralph_dir/prompt-template.txt"
  fi
  if [[ -n "$OPT_MODEL" ]]; then
    info "  Model: $OPT_MODEL"
  fi
  if [[ -n "$OPT_VARIANT" ]]; then
    info "  Variant: $OPT_VARIANT"
  fi

  if [[ "$OPT_NO_TMUX" == "true" ]]; then
    # Run in foreground (blocking)
    info "Running in foreground mode..."

    # Save state with PID of this process
    set_session "$session_name" \
      "dir=$target_dir" \
      "task_file=$OPT_TASK_FILE" \
      "pid=$$" \
      "tmux_session=" \
      "started_at=$(date -Iseconds)" \
      "iteration=1" \
      "max_iterations=$OPT_MAX_ITERATIONS" \
      "status=running" \
      "last_task_count=$initial_count" \
      "completion_marker=$OPT_COMPLETION_MARKER" \
      "log_file=$log_file" \
      "backend=$backend" \
      "model=$OPT_MODEL" \
      "variant=$OPT_VARIANT" \
      "webhook=$OPT_WEBHOOK"

    GRALPH_STATE_CALLBACK="_update_session_state"
    _update_session_state() {
      set_session "$1" iteration="$2" status="$3" last_task_count="$4"
    }
    export GRALPH_STATE_CALLBACK

    # Set backend for the loop
    export GRALPH_BACKEND="$backend"
    if [[ -n "$OPT_VARIANT" ]]; then
      export GRALPH_VARIANT="$OPT_VARIANT"
    fi

    # Run the loop directly
    run_loop \
      "$target_dir" \
      "$OPT_TASK_FILE" \
      "$OPT_MAX_ITERATIONS" \
      "$OPT_COMPLETION_MARKER" \
      "$OPT_MODEL" \
      "$session_name"

    local exit_code=$?

    # Update state based on result
    if [[ $exit_code -eq 0 ]]; then
      set_session "$session_name" "status=complete"
    else
      set_session "$session_name" "status=failed"
    fi

    return $exit_code
  else
    # Run in tmux session (background)

    # Check if tmux is available
    if ! command -v tmux &>/dev/null; then
      die "tmux is required for background mode. Install tmux or use --no-tmux flag."
    fi

    # Kill existing tmux session if it exists
    tmux kill-session -t "$tmux_session" 2>/dev/null || true

    # Build the command to run in tmux
    # We need to source the libs and call run_loop
    # Escape all user-provided values to handle special characters safely
    local esc_lib_dir esc_backend esc_variant esc_target_dir esc_task_file
    local esc_max_iterations esc_completion_marker esc_model esc_session_name
    local esc_path esc_opencode_config
    esc_lib_dir=$(escape_single_quote "$LIB_DIR")
    esc_backend=$(escape_single_quote "$backend")
    esc_variant=$(escape_single_quote "$OPT_VARIANT")
    esc_target_dir=$(escape_single_quote "$target_dir")
    esc_task_file=$(escape_single_quote "$OPT_TASK_FILE")
    esc_max_iterations=$(escape_single_quote "$OPT_MAX_ITERATIONS")
    esc_completion_marker=$(escape_single_quote "$OPT_COMPLETION_MARKER")
    esc_model=$(escape_single_quote "$OPT_MODEL")
    esc_session_name=$(escape_single_quote "$session_name")
    esc_path=$(escape_single_quote "$PATH")
    esc_opencode_config=$(escape_single_quote "$target_dir/opencode.json")

    local gralph_cmd="export PATH='${esc_path}' && "
    gralph_cmd+="export OPENCODE_CONFIG='${esc_opencode_config}' && "
    gralph_cmd+="cd '${esc_target_dir}' && "
    gralph_cmd+="source '${esc_lib_dir}/state.sh' && source '${esc_lib_dir}/backends/common.sh' && source '${esc_lib_dir}/core.sh' && "
    gralph_cmd+="export GRALPH_BACKEND='${esc_backend}' && "
    if [[ -n "$OPT_VARIANT" ]]; then
      gralph_cmd+="export GRALPH_VARIANT='${esc_variant}' && "
    fi
    gralph_cmd+="init_backend '${esc_backend}' && "
    gralph_cmd+="GRALPH_STATE_CALLBACK=_update_session_state "
    gralph_cmd+="_update_session_state() { "
    gralph_cmd+="  set_session \"\$1\" iteration=\"\$2\" status=\"\$3\" last_task_count=\"\$4\"; "
    gralph_cmd+="}; "
    gralph_cmd+="run_loop "
    gralph_cmd+="'${esc_target_dir}' "
    gralph_cmd+="'${esc_task_file}' "
    gralph_cmd+="'${esc_max_iterations}' "
    gralph_cmd+="'${esc_completion_marker}' "
    gralph_cmd+="'${esc_model}' "
    gralph_cmd+="'${esc_session_name}'; "
    gralph_cmd+="exit_code=\$?; "
    gralph_cmd+="if [ \$exit_code -eq 0 ]; then "
    gralph_cmd+="  set_session '${esc_session_name}' status=complete; "
    gralph_cmd+="else "
    gralph_cmd+="  set_session '${esc_session_name}' status=failed; "
    gralph_cmd+="fi"

    # Start tmux session
    local bash_bin
    bash_bin="$(command -v bash || echo "bash")"
    tmux new-session -d -s "$tmux_session" "$bash_bin" -lc "$gralph_cmd"

    # Get the PID of the tmux session's shell
    local tmux_pid
    tmux_pid=$(tmux list-panes -t "$tmux_session" -F '#{pane_pid}' 2>/dev/null | head -1)

    # Save state
    set_session "$session_name" \
      "dir=$target_dir" \
      "task_file=$OPT_TASK_FILE" \
      "pid=$tmux_pid" \
      "tmux_session=$tmux_session" \
      "started_at=$(date -Iseconds)" \
      "iteration=1" \
      "max_iterations=$OPT_MAX_ITERATIONS" \
      "status=running" \
      "last_task_count=$initial_count" \
      "completion_marker=$OPT_COMPLETION_MARKER" \
      "log_file=$log_file" \
      "backend=$backend" \
      "model=$OPT_MODEL" \
      "variant=$OPT_VARIANT" \
      "webhook=$OPT_WEBHOOK"

    success "Gralph loop started in tmux session: $tmux_session"
    echo ""
    echo "Useful commands:"
    echo "  gralph status            - View all running loops"
    echo "  gralph logs $session_name      - View logs"
    echo "  gralph logs $session_name --follow - Follow logs"
    echo "  gralph stop $session_name      - Stop this loop"
    echo "  tmux attach -t $tmux_session  - Attach to tmux session"
  fi
}

# cmd_stop() - Stop a running gralph loop
# Finds session by name, kills tmux session, updates state
cmd_stop() {
  # Source library files
  source_libs

  # Ensure state is initialized
  if ! init_state; then
    die "Failed to initialize state"
  fi

  # Handle --all flag
  if [[ "$OPT_ALL" == "true" ]]; then
    local sessions
    sessions=$(list_sessions)

    if [[ -z "$sessions" ]] || [[ "$sessions" == "[]" ]]; then
      info "No sessions found"
      return 0
    fi

    local stopped_count=0
    local session_names
    session_names=$(echo "$sessions" | jq -r '.[].name // empty' 2>/dev/null)

    for session_name in $session_names; do
      local session
      session=$(get_session "$session_name")
      if [[ -z "$session" ]]; then
        continue
      fi

      local status
      status=$(echo "$session" | jq -r '.status // "unknown"')

      # Skip already stopped/completed sessions
      if [[ "$status" != "running" ]]; then
        continue
      fi

      local tmux_session
      tmux_session=$(echo "$session" | jq -r '.tmux_session // empty')

      # Kill tmux session if it exists
      if [[ -n "$tmux_session" ]]; then
        if tmux kill-session -t "$tmux_session" 2>/dev/null; then
          info "Killed tmux session: $tmux_session"
        fi
      else
        # Foreground mode - kill by PID
        local pid
        pid=$(echo "$session" | jq -r '.pid // empty')
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
          kill "$pid" 2>/dev/null || true
          info "Killed process: $pid"
        fi
      fi

      # Update state to stopped
      set_session "$session_name" status="stopped" pid="" tmux_session=""
      stopped_count=$((stopped_count + 1))
      info "Stopped session: $session_name"
    done

    if [[ $stopped_count -eq 0 ]]; then
      info "No running sessions to stop"
    else
      success "Stopped $stopped_count session(s)"
    fi
    return 0
  fi

  # Single session stop mode
  local session_name="${POSITIONAL_ARGS[0]}"

  if [[ -z "$session_name" ]]; then
    die "Session name is required. Usage: gralph stop <name> or gralph stop --all"
  fi

  # Find session by name
  local session
  if ! session=$(get_session "$session_name"); then
    die "Session not found: $session_name"
  fi

  local status
  status=$(echo "$session" | jq -r '.status // "unknown"')

  # Warn if not running
  if [[ "$status" != "running" ]]; then
    warn "Session '$session_name' is not running (status: $status)"
  fi

  local tmux_session
  tmux_session=$(echo "$session" | jq -r '.tmux_session // empty')

  # Kill tmux session if it exists
  if [[ -n "$tmux_session" ]]; then
    if tmux kill-session -t "$tmux_session" 2>/dev/null; then
      info "Killed tmux session: $tmux_session"
    else
      warn "Tmux session '$tmux_session' not found (may have already exited)"
    fi
  else
    # Foreground mode - kill by PID
    local pid
    pid=$(echo "$session" | jq -r '.pid // empty')
    if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
      kill "$pid" 2>/dev/null || true
      info "Killed process: $pid"
    else
      warn "Process not found (may have already exited)"
    fi
  fi

  # Update state to stopped
  set_session "$session_name" status="stopped" pid="" tmux_session=""

  # Send failure notification for manual stop if configured
  local notify_on_fail webhook_url project_dir iteration max_iter remaining_tasks
  project_dir=$(echo "$session" | jq -r '.dir // ""')
  iteration=$(echo "$session" | jq -r '.iteration // 0')
  max_iter=$(echo "$session" | jq -r '.max_iterations // 0')
  remaining_tasks=$(echo "$session" | jq -r '.last_task_count // 0')

  if [[ -f "$LIB_DIR/config.sh" ]]; then
    source "$LIB_DIR/config.sh"
    load_config "$project_dir"
    notify_on_fail=$(get_config "notifications.on_fail" "false")
    webhook_url=$(get_config "notifications.webhook" "")

    if [[ "$notify_on_fail" == "true" && -n "$webhook_url" ]]; then
      if [[ -f "$LIB_DIR/notify.sh" ]]; then
        source "$LIB_DIR/notify.sh"
        notify_failed "$session_name" "$webhook_url" "manual_stop" "$project_dir" \
          "$iteration" "$max_iter" "$remaining_tasks" "" ||
          warn "Failed to send stop notification"
      fi
    fi
  fi

  success "Stopped session: $session_name"
}

# cmd_status() - Show status of all gralph loops
# Lists all sessions in a formatted table with color coding
cmd_status() {
  # Source library files
  source_libs

  # Ensure state is initialized
  if ! init_state; then
    die "Failed to initialize state"
  fi

  # Clean up stale sessions first (remove dead sessions)
  cleanup_stale >/dev/null 2>&1

  # Get all sessions
  local sessions
  sessions=$(list_sessions)

  if [[ -z "$sessions" ]] || [[ "$sessions" == "[]" ]]; then
    info "No sessions found"
    echo ""
    echo "Start a new loop with: gralph start <directory>"
    return 0
  fi

  # Calculate column widths (minimum widths for headers)
  local name_width=8
  local dir_width=30
  local iter_width=10
  local status_width=10
  local remaining_width=10

  # Find max widths from data
  local session_count
  session_count=$(echo "$sessions" | jq -r 'length')

  for ((i = 0; i < session_count; i++)); do
    local name dir
    name=$(echo "$sessions" | jq -r ".[$i].name // \"\"")
    dir=$(echo "$sessions" | jq -r ".[$i].dir // \"\"")

    # Truncate long dirs for display
    if [[ ${#dir} -gt 40 ]]; then
      dir="...${dir: -37}"
    fi

    [[ ${#name} -gt $name_width ]] && name_width=${#name}
    [[ ${#dir} -gt $dir_width ]] && dir_width=${#dir}
  done

  # Print header
  printf "${BLUE}%-${name_width}s  %-${dir_width}s  %-${iter_width}s  %-${status_width}s  %-${remaining_width}s${NC}\n" \
    "NAME" "DIR" "ITERATION" "STATUS" "REMAINING"
  printf "%-${name_width}s  %-${dir_width}s  %-${iter_width}s  %-${status_width}s  %-${remaining_width}s\n" \
    "$(printf '%*s' "$name_width" '' | tr ' ' '-')" \
    "$(printf '%*s' "$dir_width" '' | tr ' ' '-')" \
    "$(printf '%*s' "$iter_width" '' | tr ' ' '-')" \
    "$(printf '%*s' "$status_width" '' | tr ' ' '-')" \
    "$(printf '%*s' "$remaining_width" '' | tr ' ' '-')"

  # Print each session row
  for ((i = 0; i < session_count; i++)); do
    local name dir iteration max_iterations status last_task_count task_file
    name=$(echo "$sessions" | jq -r ".[$i].name // \"unknown\"")
    dir=$(echo "$sessions" | jq -r ".[$i].dir // \"\"")
    iteration=$(echo "$sessions" | jq -r ".[$i].iteration // 0")
    max_iterations=$(echo "$sessions" | jq -r ".[$i].max_iterations // 0")
    status=$(echo "$sessions" | jq -r ".[$i].status // \"unknown\"")
    last_task_count=$(echo "$sessions" | jq -r ".[$i].last_task_count // \"?\"")
    task_file=$(echo "$sessions" | jq -r ".[$i].task_file // \"PRD.md\"")

    # Try to get current remaining count if directory exists
    local current_remaining="$last_task_count"
    if [[ -d "$dir" ]] && [[ -f "$dir/$task_file" ]]; then
      current_remaining=$(count_remaining_tasks "$dir/$task_file" 2>/dev/null | head -n1 || true)
      if [[ -z "$current_remaining" ]]; then
        current_remaining="$last_task_count"
      fi
    fi

    # Truncate long dirs for display
    local display_dir="$dir"
    if [[ ${#display_dir} -gt 40 ]]; then
      display_dir="...${display_dir: -37}"
    fi

    # Format iteration as "current/max"
    local iter_display="${iteration}/${max_iterations}"

    # Format remaining tasks
    local remaining_display
    if [[ "$current_remaining" == "0" ]]; then
      remaining_display="0 tasks"
    elif [[ "$current_remaining" == "1" ]]; then
      remaining_display="1 task"
    else
      remaining_display="${current_remaining} tasks"
    fi

    # Determine color based on status
    local status_color
    case "$status" in
    complete | completed)
      status_color="$GREEN"
      ;;
    running)
      status_color="$YELLOW"
      ;;
    failed | stale | stopped)
      status_color="$RED"
      ;;
    *)
      status_color="$NC"
      ;;
    esac

    # Print row with colored status
    printf "%-${name_width}s  %-${dir_width}s  %-${iter_width}s  ${status_color}%-${status_width}s${NC}  %-${remaining_width}s\n" \
      "$name" "$display_dir" "$iter_display" "$status" "$remaining_display"
  done

  echo ""
  echo "Commands: gralph logs <name>, gralph stop <name>, gralph resume"
}

# cmd_logs() - View logs for a gralph loop session
# Tails the log file, supports --follow flag
cmd_logs() {
  # Source library files
  source_libs

  # Ensure state is initialized
  if ! init_state; then
    die "Failed to initialize state"
  fi

  # Get session name from positional args
  local session_name="${POSITIONAL_ARGS[0]}"

  if [[ -z "$session_name" ]]; then
    die "Session name is required. Usage: gralph logs <name> [--follow]"
  fi

  # Find session by name
  local session
  if ! session=$(get_session "$session_name"); then
    die "Session not found: $session_name"
  fi

  # Get log file path
  local log_file
  log_file=$(echo "$session" | jq -r '.log_file // empty')

  if [[ -z "$log_file" ]]; then
    # Try to construct log file path from session dir using per-session naming
    local session_dir
    session_dir=$(echo "$session" | jq -r '.dir // empty')
    if [[ -n "$session_dir" ]]; then
      log_file="$session_dir/.gralph/${session_name}.log"
    fi
  fi

  if [[ -z "$log_file" ]]; then
    die "Cannot determine log file path for session: $session_name"
  fi

  if [[ ! -f "$log_file" ]]; then
    die "Log file does not exist: $log_file"
  fi

  # Display session info
  local status
  status=$(echo "$session" | jq -r '.status // "unknown"')
  info "Session: $session_name (status: $status)"
  info "Log file: $log_file"
  echo ""

  # Tail the log file
  if [[ "$OPT_FOLLOW" == "true" ]]; then
    # Follow mode - continuous tail
    tail -f "$log_file"
  else
    # Default mode - show last 100 lines
    tail -n 100 "$log_file"
  fi
}

# cmd_resume() - Resume crashed/stopped loops
# Finds sessions marked running with dead PIDs and restarts their tmux sessions
cmd_resume() {
  # Source library files
  source_libs

  # Ensure state is initialized
  if ! init_state; then
    die "Failed to initialize state"
  fi

  # Get optional session name from positional args
  local target_session="${POSITIONAL_ARGS[0]}"

  # Get all sessions
  local sessions
  sessions=$(list_sessions)

  if [[ -z "$sessions" ]] || [[ "$sessions" == "[]" ]]; then
    info "No sessions found"
    return 0
  fi

  local resumed_count=0
  local session_names

  if [[ -n "$target_session" ]]; then
    # Resume specific session
    session_names="$target_session"
  else
    # Resume all stale/stopped sessions
    session_names=$(echo "$sessions" | jq -r '.[].name // empty' 2>/dev/null)
  fi

  for session_name in $session_names; do
    local session
    if ! session=$(get_session "$session_name"); then
      if [[ -n "$target_session" ]]; then
        die "Session not found: $session_name"
      fi
      continue
    fi

    local status pid dir task_file max_iterations completion_marker backend model variant webhook iteration
    status=$(echo "$session" | jq -r '.status // "unknown"')
    pid=$(echo "$session" | jq -r '.pid // empty')
    dir=$(echo "$session" | jq -r '.dir // empty')
    task_file=$(echo "$session" | jq -r '.task_file // "PRD.md"')
    max_iterations=$(echo "$session" | jq -r '.max_iterations // 30')
    completion_marker=$(echo "$session" | jq -r '.completion_marker // "COMPLETE"')
    backend=$(echo "$session" | jq -r '.backend // "claude"')
    model=$(echo "$session" | jq -r '.model // empty')
    variant=$(echo "$session" | jq -r '.variant // empty')
    webhook=$(echo "$session" | jq -r '.webhook // empty')
    iteration=$(echo "$session" | jq -r '.iteration // 1')

    # Check if session should be resumed
    local should_resume=false

    if [[ "$status" == "running" ]]; then
      # Check if PID is dead
      if [[ -z "$pid" ]] || [[ "$pid" == "null" ]] || ! kill -0 "$pid" 2>/dev/null; then
        should_resume=true
      fi
    elif [[ "$status" == "stale" ]] || [[ "$status" == "stopped" ]]; then
      should_resume=true
    fi

    if [[ "$should_resume" != "true" ]]; then
      if [[ -n "$target_session" ]]; then
        warn "Session '$session_name' is already running (PID: $pid) or completed (status: $status)"
      fi
      continue
    fi

    # Validate directory exists
    if [[ ! -d "$dir" ]]; then
      warn "Skipping '$session_name': directory no longer exists: $dir"
      continue
    fi

    # Validate task file exists
    if [[ ! -f "$dir/$task_file" ]]; then
      warn "Skipping '$session_name': task file not found: $dir/$task_file"
      continue
    fi

    info "Resuming session: $session_name (was at iteration $iteration)"

    local tmux_session="gralph-$session_name"
    local log_file="$dir/.gralph/${session_name}.log"
    local gralph_dir="$dir/.gralph"

    # Ensure .gralph directory exists
    mkdir -p "$gralph_dir"

    # Get current task count
    local current_count
    current_count=$(grep -cE '^\s*- \[ \]' "$dir/$task_file" 2>/dev/null || true)

    # Kill any existing tmux session with the same name
    tmux kill-session -t "$tmux_session" 2>/dev/null || true

    # Build the command to run in tmux
    # Escape all user-provided values to handle special characters safely
    local esc_lib_dir esc_backend esc_variant esc_dir esc_task_file
    local esc_max_iterations esc_completion_marker esc_model esc_session_name
    local esc_path esc_opencode_config
    esc_lib_dir=$(escape_single_quote "$LIB_DIR")
    esc_backend=$(escape_single_quote "$backend")
    esc_variant=$(escape_single_quote "$variant")
    esc_dir=$(escape_single_quote "$dir")
    esc_task_file=$(escape_single_quote "$task_file")
    esc_max_iterations=$(escape_single_quote "$max_iterations")
    esc_completion_marker=$(escape_single_quote "$completion_marker")
    esc_model=$(escape_single_quote "$model")
    esc_session_name=$(escape_single_quote "$session_name")
    esc_path=$(escape_single_quote "$PATH")
    esc_opencode_config=$(escape_single_quote "$dir/opencode.json")

    local gralph_cmd="export PATH='${esc_path}' && "
    gralph_cmd+="export OPENCODE_CONFIG='${esc_opencode_config}' && "
    gralph_cmd+="cd '${esc_dir}' && "
    gralph_cmd+="source '${esc_lib_dir}/state.sh' && source '${esc_lib_dir}/backends/common.sh' && source '${esc_lib_dir}/core.sh' && "
    gralph_cmd+="export GRALPH_BACKEND='${esc_backend}' && "
    if [[ -n "$variant" ]]; then
      gralph_cmd+="export GRALPH_VARIANT='${esc_variant}' && "
    fi
    gralph_cmd+="init_backend '${esc_backend}' && "
    gralph_cmd+="GRALPH_STATE_CALLBACK=_update_session_state "
    gralph_cmd+="_update_session_state() { "
    gralph_cmd+="  set_session \"\$1\" iteration=\"\$2\" status=\"\$3\" last_task_count=\"\$4\"; "
    gralph_cmd+="}; "
    gralph_cmd+="run_loop "
    gralph_cmd+="'${esc_dir}' "
    gralph_cmd+="'${esc_task_file}' "
    gralph_cmd+="'${esc_max_iterations}' "
    gralph_cmd+="'${esc_completion_marker}' "
    gralph_cmd+="'${esc_model}' "
    gralph_cmd+="'${esc_session_name}'; "
    gralph_cmd+="exit_code=\$?; "
    gralph_cmd+="if [ \$exit_code -eq 0 ]; then "
    gralph_cmd+="  set_session '${esc_session_name}' status=complete; "
    gralph_cmd+="else "
    gralph_cmd+="  set_session '${esc_session_name}' status=failed; "
    gralph_cmd+="fi"

    # Start tmux session
    local bash_bin
    bash_bin="$(command -v bash || echo "bash")"
    tmux new-session -d -s "$tmux_session" "$bash_bin" -lc "$gralph_cmd"

    # Get the PID of the tmux session's shell
    local tmux_pid
    tmux_pid=$(tmux list-panes -t "$tmux_session" -F '#{pane_pid}' 2>/dev/null | head -1)

    # Update state with new PID and status
    set_session "$session_name" \
      "pid=$tmux_pid" \
      "tmux_session=$tmux_session" \
      "status=running" \
      "last_task_count=$current_count"

    resumed_count=$((resumed_count + 1))
    success "Resumed session: $session_name in tmux session: $tmux_session"
  done

  if [[ $resumed_count -eq 0 ]]; then
    info "No sessions to resume"
  else
    echo ""
    success "Resumed $resumed_count session(s)"
    echo ""
    echo "Commands: gralph status, gralph logs <name>, gralph stop <name>"
  fi
}

cmd_backends() {
  # Source library files
  source_libs

  echo "Available AI backends:"
  echo ""

  local backends
  backends=$(list_available_backends)

  for backend in $backends; do
    echo -n "  $backend"

    # Try to load backend to check if installed
    if load_backend "$backend" 2>/dev/null; then
      if backend_check_installed; then
        echo -e " ${GREEN}(installed)${NC}"
        echo "      Models: $(backend_get_models)"
      else
        echo -e " ${YELLOW}(not installed)${NC}"
        echo "      Install: $(backend_get_install_hint)"
      fi
    else
      echo -e " ${RED}(error loading)${NC}"
    fi
    echo ""
  done

  echo "Usage: gralph start <dir> --backend <name>"
}

cmd_config() {
  # Source configuration library
  if [[ -f "$LIB_DIR/config.sh" ]]; then
    source "$LIB_DIR/config.sh"
  else
    die "Library not found: $LIB_DIR/config.sh"
  fi

  local subcommand="${POSITIONAL_ARGS[0]}"

  case "$subcommand" in
  get)
    local key="${POSITIONAL_ARGS[1]}"
    if [[ -z "$key" ]]; then
      die "Usage: gralph config get <key>"
    fi

    load_config "$(pwd)"
    if config_exists "$key"; then
      get_config "$key"
    else
      die "Config key not found: $key"
    fi
    ;;
  set)
    local key="${POSITIONAL_ARGS[1]}"
    local value="${POSITIONAL_ARGS[2]}"
    if [[ -z "$key" || -z "$value" ]]; then
      die "Usage: gralph config set <key> <value>"
    fi

    if set_config "$key" "$value"; then
      success "Updated config: $key"
    else
      die "Failed to set config: $key"
    fi
    ;;
  list | "")
    load_config "$(pwd)"
    list_config
    ;;
  *)
    die "Unknown config command: $subcommand. Use 'gralph config get <key>' or 'gralph config set <key> <value>'"
    ;;
  esac
}

cmd_prd_create() {
  local target_dir="${OPT_PRD_DIR:-${POSITIONAL_ARGS[1]:-$(pwd)}}"

  source_libs

  if [[ -z "$target_dir" ]]; then
    target_dir="$(pwd)"
  fi

  if [[ ! -d "$target_dir" ]]; then
    die "Directory does not exist: $target_dir"
  fi

  target_dir=$(cd "$target_dir" && pwd)

  local interactive="$OPT_PRD_INTERACTIVE"
  if [[ "$OPT_PRD_INTERACTIVE_SET" != "true" ]]; then
    if [[ ! -t 0 || ! -t 1 ]]; then
      interactive=false
    fi
  fi

  if [[ "$interactive" == "true" ]]; then
    info "Interactive mode: follow the numbered steps. Press Enter to skip optional prompts."
  fi

  local goal="$OPT_PRD_GOAL"
  if [[ -z "$goal" && "$interactive" == "true" ]]; then
    info "Step 1/6: Project goal (required). Press Enter to skip if already provided."
    if [[ "$OPT_PRD_MULTILINE" == "true" ]]; then
      goal=$(prompt_multiline "Goal (required)")
    else
      goal=$(prompt_input "Goal (required)" "")
    fi
  fi

  if [[ -z "$goal" ]]; then
    die "Goal is required. Use --goal or run interactively."
  fi

  local constraints="$OPT_PRD_CONSTRAINTS"
  if [[ -z "$constraints" && "$interactive" == "true" ]]; then
    info "Step 2/6: Constraints or requirements (optional). Press Enter to skip."
    if [[ "$OPT_PRD_MULTILINE" == "true" ]]; then
      constraints=$(prompt_multiline "Constraints (optional)")
    else
      constraints=$(prompt_input "Constraints (optional)" "")
    fi
  fi
  if [[ -z "$constraints" ]]; then
    constraints="None."
  fi

  local sources_input="$OPT_PRD_SOURCES"
  if [[ -z "$sources_input" && "$interactive" == "true" ]]; then
    info "Step 3/6: External sources (comma-separated URLs). Press Enter to skip."
    sources_input=$(prompt_input "Sources (optional)" "")
  fi

  local output_path="$OPT_PRD_OUTPUT"
  if [[ -z "$output_path" && "$interactive" == "true" ]]; then
    info "Step 4/6: Output file (press Enter for PRD.generated.md)."
    output_path=$(prompt_input "PRD output file" "PRD.generated.md")
  fi
  if [[ -z "$output_path" ]]; then
    output_path="PRD.generated.md"
  fi
  if [[ "$output_path" != /* ]]; then
    output_path="$target_dir/$output_path"
  fi

  if [[ -e "$output_path" && "$OPT_PRD_FORCE" != "true" ]]; then
    if [[ "$interactive" == "true" ]]; then
      local overwrite
      overwrite=$(prompt_input "File exists. Overwrite? (y/N)" "N")
      if ! [[ "$overwrite" =~ ^[Yy]$ ]]; then
        die "Output file exists: $output_path (use --force to overwrite)"
      fi
    else
      die "Output file exists: $output_path (use --force to overwrite)"
    fi
  fi

  info "Generating PRD in $target_dir"
  info "Output file: $output_path"

  # Load configuration and backend support
  if [[ -f "$LIB_DIR/config.sh" ]]; then
    source "$LIB_DIR/config.sh"
    load_config "$target_dir"
  else
    die "Library not found: $LIB_DIR/config.sh"
  fi

  if [[ -f "$LIB_DIR/prd.sh" ]]; then
    source "$LIB_DIR/prd.sh"
  else
    warn "PRD validation library not found: $LIB_DIR/prd.sh"
  fi

  local backend="$OPT_BACKEND"
  if [[ -z "$backend" ]]; then
    backend=$(get_config "defaults.backend" "claude")
  fi

  local model="$OPT_MODEL"
  if [[ -z "$model" ]]; then
    model=$(get_config "defaults.model" "")
  fi
  if [[ -z "$model" && "$backend" == "opencode" ]]; then
    model=$(get_config "opencode.default_model" "")
  fi

  if [[ -z "$backend" ]]; then
    backend="claude"
  fi

  if ! init_backend "$backend"; then
    die "Failed to initialize backend: $backend"
  fi

  info "Using backend: $backend"
  if [[ -n "$model" ]]; then
    info "Using model: $model"
  fi

  local stack_summary_text=""
  local detected_stack_list="None detected"

  if declare -f prd_detect_stack >/dev/null; then
    prd_detect_stack "$target_dir"
  fi

  if [[ ${#PRD_STACK_IDS[@]} -gt 0 ]]; then
    local item
    detected_stack_list=""
    for item in "${PRD_STACK_IDS[@]}"; do
      if [[ -z "$detected_stack_list" ]]; then
        detected_stack_list="$item"
      else
        detected_stack_list+=", $item"
      fi
    done
  fi

  if [[ "$interactive" == "true" ]]; then
    info "Step 5/6: Stack detection"
    if [[ ${#PRD_STACK_IDS[@]} -gt 0 ]]; then
      echo "Detected stacks:"
      local idx=1
      local stack_name
      for stack_name in "${PRD_STACK_IDS[@]}"; do
        echo "  $idx) $stack_name"
        idx=$((idx + 1))
      done
    else
      echo "No stack files detected."
    fi
  fi

  if [[ "$interactive" == "true" && ${#PRD_STACK_IDS[@]} -gt 1 ]]; then
    local confirm_stacks
    confirm_stacks=$(prompt_input "Use all detected stacks? (Y/n)" "Y")
    if [[ "$confirm_stacks" =~ ^[Nn]$ ]]; then
      local selection
      selection=$(prompt_input "Select stacks by number (comma-separated, press Enter for all)" "")
      if [[ -n "$selection" ]]; then
        PRD_STACK_SELECTED_IDS=()
        IFS=',' read -r -a _indexes <<<"$selection"
        local idx
        for idx in "${_indexes[@]}"; do
          idx=$(trim_whitespace "$idx")
          if [[ "$idx" =~ ^[0-9]+$ ]] && ((idx >= 1 && idx <= ${#PRD_STACK_IDS[@]})); then
            PRD_STACK_SELECTED_IDS+=("${PRD_STACK_IDS[$((idx - 1))]}")
          fi
        done
        if [[ ${#PRD_STACK_SELECTED_IDS[@]} -eq 0 ]]; then
          PRD_STACK_SELECTED_IDS=("${PRD_STACK_IDS[@]}")
          warn "No valid stack selection provided; using all detected stacks."
        fi
      fi
    fi
  fi

  if declare -f prd_format_stack_summary >/dev/null; then
    stack_summary_text=$(prd_format_stack_summary "2")
  fi

  local config_context_files=""
  if [[ -f "$LIB_DIR/config.sh" ]]; then
    config_context_files=$(get_config "defaults.context_files" "")
  fi

  local context_files
  context_files=$(build_context_file_list "$target_dir" "$OPT_PRD_CONTEXT" "$config_context_files")

  local context_section="None."
  if [[ -n "$context_files" ]]; then
    context_section="$context_files"
  fi

  local -a sources_list=()
  local sources_origin="user"
  local normalized_sources
  normalized_sources=$(normalize_csv_list "$sources_input")
  if [[ -n "$normalized_sources" ]]; then
    while IFS= read -r line; do
      sources_list+=("$line")
    done <<<"$normalized_sources"
  fi

  if [[ ${#sources_list[@]} -eq 0 ]]; then
    sources_origin="official"
    local official_sources
    official_sources=$(collect_official_sources)
    if [[ -n "$official_sources" ]]; then
      while IFS= read -r line; do
        sources_list+=("$line")
      done <<<"$official_sources"
    fi
  fi

  if [[ ${#sources_list[@]} -eq 0 ]]; then
    sources_origin="search"
    local search_query="$goal"
    if [[ ${#PRD_STACK_SELECTED_IDS[@]} -gt 0 ]]; then
      search_query="$goal ${PRD_STACK_SELECTED_IDS[*]} documentation"
    fi
    local search_sources
    search_sources=$(search_web_sources "$search_query" 5)
    if [[ -n "$search_sources" ]]; then
      while IFS= read -r line; do
        sources_list+=("$line")
      done <<<"$search_sources"
    fi
  fi

  if [[ ${#sources_list[@]} -gt 0 ]]; then
    local deduped_sources
    deduped_sources=$(dedupe_list "${sources_list[@]}")
    sources_list=()
    while IFS= read -r line; do
      sources_list+=("$line")
    done <<<"$deduped_sources"
  fi

  local sources_section="None."
  local warnings_section=""
  if [[ ${#sources_list[@]} -gt 0 ]]; then
    sources_section=$(printf '%s\n' "${sources_list[@]}")
  else
    sources_origin="none"
    warnings_section="No reliable external sources were provided or discovered. Verify requirements and stack assumptions before implementation."
  fi

  if [[ "$interactive" == "true" ]]; then
    info "Step 6/6: Review summary"
  else
    info "Summary"
  fi
  echo "Summary:"
  echo "  Goal: $goal"
  echo "  Constraints: $constraints"
  echo "  Output: $output_path"
  echo "  Detected stacks: $detected_stack_list"
  echo "  Sources: $sources_origin"
  echo "  Allow missing context: $OPT_PRD_ALLOW_MISSING_CONTEXT"
  echo "  Backend: $backend"
  if [[ -n "$model" ]]; then
    echo "  Model: $model"
  fi
  echo "  Context files:"
  if [[ -n "$context_files" ]]; then
    while IFS= read -r line; do
      echo "    - $line"
    done <<<"$context_files"
  else
    echo "    - None"
  fi

  if [[ "$interactive" == "true" ]]; then
    local proceed
    proceed=$(prompt_input "Proceed to generate PRD? (y/N)" "N")
    if ! [[ "$proceed" =~ ^[Yy]$ ]]; then
      die "PRD generation cancelled."
    fi
  else
    info "Non-interactive mode: skipping confirmation."
  fi

  local template_text
  template_text=$(get_prd_template_text "$target_dir")

  local stack_summary_prompt="None detected."
  if [[ -n "$stack_summary_text" ]]; then
    stack_summary_prompt="$stack_summary_text"
  fi

  local warning_prompt="None."
  if [[ -n "$warnings_section" ]]; then
    warning_prompt="$warnings_section"
  fi

  local prompt
  prompt=$(
    cat <<EOF
You are generating a gralph PRD in markdown. The output must be spec-compliant and grounded in the repository.

Project directory: $target_dir

Goal:
$goal

Constraints:
$constraints

Detected stack summary (from repository files):
$stack_summary_prompt

Sources (authoritative URLs or references):
$sources_section

Warnings (only include in the PRD if Sources is empty):
$warning_prompt

Context files (read these first if present):
$context_section

Requirements:
- Output only the PRD markdown with no commentary or code fences.
- Use ASCII only.
- Do not include an "Open Questions" section.
- Do not use any checkboxes outside task blocks.
- Context Bundle entries must be real files in the repo and must be selected from the Context files list above.
- If a task creates new files, do not list the new files in Context Bundle; cite the closest existing files instead.
- Use atomic, granular tasks grounded in the repo and context files.
- Each task block must use a '### Task <ID>' header and include **ID**, **Context Bundle**, **DoD**, **Checklist**, **Dependencies**.
- Each task block must contain exactly one unchecked task line like '- [ ] <ID> <summary>'.
- If Sources is empty, include a 'Warnings' section with the warning text above and no checkboxes.
- Do not invent stack, frameworks, or files not supported by the context files and stack summary.

Template:
$template_text
EOF
  )

  local tmpfile
  local tmp_prd
  local tmp_err
  local raw_output
  tmpfile=$(mktemp)
  tmp_prd=$(mktemp)
  tmp_err=$(mktemp)
  raw_output=$(mktemp)

  local backend_exit_code=0
  if GRALPH_RAW_OUTPUT_FILE="$raw_output" backend_run_iteration "$prompt" "$model" "$tmpfile"; then
    backend_exit_code=0
  else
    backend_exit_code=$?
  fi

  if [[ $backend_exit_code -ne 0 ]]; then
    warn "PRD generation failed (backend exit code $backend_exit_code)."
    if [[ -s "$raw_output" ]]; then
      warn "Raw backend output saved to: $raw_output"
    fi
    rm -f "$tmp_prd" "$tmp_err" "$tmpfile"
    return 1
  fi

  local result
  result=$(backend_parse_text "$tmpfile" || true)
  if [[ -z "$result" ]]; then
    warn "PRD generation returned empty output."
    if [[ -s "$raw_output" ]]; then
      warn "Raw backend output saved to: $raw_output"
    fi
    rm -f "$tmp_prd" "$tmp_err" "$tmpfile"
    return 1
  fi

  printf '%s\n' "$result" >"$tmp_prd"

  local allowed_context_file=""
  if [[ -n "$context_files" ]]; then
    allowed_context_file=$(mktemp)
    printf '%s\n' "$context_files" >"$allowed_context_file"
  fi

  if declare -f prd_sanitize_generated_file >/dev/null; then
    prd_sanitize_generated_file "$tmp_prd" "$target_dir" "$allowed_context_file"
  fi

  local invalid_path=""
  if declare -f prd_validate_file >/dev/null; then
    info "Validating generated PRD"
    if ! prd_validate_file "$tmp_prd" "$OPT_PRD_ALLOW_MISSING_CONTEXT" "$target_dir" 2>"$tmp_err"; then
      warn "Generated PRD failed validation."
      cat "$tmp_err" >&2
      if [[ "$OPT_PRD_FORCE" == "true" ]]; then
        invalid_path="$output_path"
      else
        if [[ "$output_path" == *.md ]]; then
          invalid_path="${output_path%.md}.invalid.md"
        else
          invalid_path="${output_path}.invalid"
        fi
      fi
      mv "$tmp_prd" "$invalid_path"
      warn "Saved invalid PRD to: $invalid_path"
      rm -f "$tmp_err" "$tmpfile" "$allowed_context_file"
      return 1
    fi
  fi

  mv "$tmp_prd" "$output_path"
  rm -f "$tmp_err" "$tmpfile" "$raw_output" "$allowed_context_file"

  success "PRD created: $output_path"
  local relative_output="$output_path"
  if [[ "$output_path" == "$target_dir"/* ]]; then
    relative_output="${output_path#"$target_dir/"}"
  fi

  echo "Next step:"
  echo "  gralph start $target_dir --task-file $relative_output --no-tmux --backend $backend --model $model --strict-prd"
}

cmd_prd() {
  local subcommand="${POSITIONAL_ARGS[0]}"

  case "$subcommand" in
  check)
    local task_file="${POSITIONAL_ARGS[1]}"
    if [[ -z "$task_file" ]]; then
      die "Usage: gralph prd check <file>"
    fi

    if [[ -f "$LIB_DIR/prd.sh" ]]; then
      source "$LIB_DIR/prd.sh"
    else
      die "Library not found: $LIB_DIR/prd.sh"
    fi

    if ! prd_validate_file "$task_file" "$OPT_PRD_ALLOW_MISSING_CONTEXT"; then
      return 1
    fi

    success "PRD validation passed: $task_file"
    ;;
  create | init | new)
    cmd_prd_create
    ;;
  "")
    die "Usage: gralph prd check <file> | gralph prd create"
    ;;
  *)
    die "Unknown prd command: $subcommand. Use 'gralph prd check <file>' or 'gralph prd create'"
    ;;
  esac
}

cmd_worktree_create() {
  local task_id="${POSITIONAL_ARGS[1]}"

  if [[ -z "$task_id" ]]; then
    die "Usage: gralph worktree create <ID>"
  fi

  if ! [[ "$task_id" =~ ^[A-Za-z]+-[0-9]+$ ]]; then
    die "Invalid task ID format: $task_id (expected like A-1)"
  fi

  local repo_root
  if ! repo_root=$(git rev-parse --show-toplevel 2>/dev/null); then
    die "Not a git repository (or any of the parent directories)"
  fi

  ensure_git_clean "$repo_root"

  local worktrees_dir="$repo_root/.worktrees"
  mkdir -p "$worktrees_dir"

  local branch_name="task-$task_id"
  local worktree_path="$worktrees_dir/$branch_name"

  if git -C "$repo_root" show-ref --verify --quiet "refs/heads/$branch_name"; then
    die "Branch already exists: $branch_name"
  fi

  if [[ -e "$worktree_path" ]]; then
    die "Worktree path already exists: $worktree_path"
  fi

  if ! git -C "$repo_root" worktree add -b "$branch_name" "$worktree_path"; then
    die "Failed to create worktree at $worktree_path"
  fi

  success "Created worktree $worktree_path on branch $branch_name"
}

cmd_worktree_finish() {
  local task_id="${POSITIONAL_ARGS[1]}"

  if [[ -z "$task_id" ]]; then
    die "Usage: gralph worktree finish <ID>"
  fi

  if ! [[ "$task_id" =~ ^[A-Za-z]+-[0-9]+$ ]]; then
    die "Invalid task ID format: $task_id (expected like A-1)"
  fi

  local repo_root
  if ! repo_root=$(git rev-parse --show-toplevel 2>/dev/null); then
    die "Not a git repository (or any of the parent directories)"
  fi

  ensure_git_clean "$repo_root"

  local branch_name="task-$task_id"
  local worktrees_dir="$repo_root/.worktrees"
  local worktree_path="$worktrees_dir/$branch_name"

  if ! git -C "$repo_root" show-ref --verify --quiet "refs/heads/$branch_name"; then
    die "Branch does not exist: $branch_name"
  fi

  if [[ ! -d "$worktree_path" ]]; then
    die "Worktree path is missing: $worktree_path (run 'gralph worktree create $task_id' first)"
  fi

  local current_branch
  current_branch=$(git -C "$repo_root" rev-parse --abbrev-ref HEAD 2>/dev/null || true)
  if [[ "$current_branch" == "$branch_name" ]]; then
    die "Cannot finish while on branch $branch_name"
  fi

  if ! git -C "$repo_root" merge --no-ff "$branch_name"; then
    die "Failed to merge branch: $branch_name"
  fi

  if ! git -C "$repo_root" worktree remove "$worktree_path"; then
    die "Failed to remove worktree at $worktree_path"
  fi

  success "Finished worktree $worktree_path and merged $branch_name"
}

cmd_worktree() {
  local subcommand="${POSITIONAL_ARGS[0]}"

  case "$subcommand" in
  create)
    cmd_worktree_create
    ;;
  finish)
    cmd_worktree_finish
    ;;
  "")
    die "Usage: gralph worktree <create|finish> <ID>"
    ;;
  *)
    die "Unknown worktree command: $subcommand. Use 'gralph worktree create <ID>' or 'gralph worktree finish <ID>'"
    ;;
  esac
}

cmd_server() {
  # Source server library
  if [[ -f "$LIB_DIR/server.sh" ]]; then
    source "$LIB_DIR/state.sh"
    source "$LIB_DIR/server.sh"
  else
    die "Library not found: $LIB_DIR/server.sh"
  fi

  # Get port, host, and token from parsed options
  local port="${OPT_PORT:-8080}"
  local host="${OPT_HOST:-127.0.0.1}"
  local token="${OPT_TOKEN:-}"
  local open="${OPT_OPEN:-false}"

  # Start the server
  start_server "$port" "$host" "$token" "$open"
}

cmd_version() {
  echo "gralph v$VERSION"
}

# Main entry point
main() {
  parse_args "$@"

  case "$COMMAND" in
  start)
    cmd_start
    ;;
  stop)
    cmd_stop
    ;;
  status)
    cmd_status
    ;;
  logs)
    cmd_logs
    ;;
  resume)
    cmd_resume
    ;;
  backends)
    cmd_backends
    ;;
  config)
    cmd_config
    ;;
  worktree)
    cmd_worktree
    ;;
  prd)
    cmd_prd
    ;;
  server)
    cmd_server
    ;;
  version | --version | -v)
    cmd_version
    ;;
  help | --help | -h)
    usage
    ;;
  "")
    usage
    ;;
  *)
    die "Unknown command: $COMMAND. Run 'gralph help' for usage."
    ;;
  esac
}

main "$@"
